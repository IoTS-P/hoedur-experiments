From ad9161e88accac69309df54df88399ba486f29fe Mon Sep 17 00:00:00 2001
From: Ruibo Lu <reaperlu@hust.edu.cn>
Date: Fri, 26 Jul 2024 22:18:56 +0800
Subject: [PATCH] mqtt: add newest mqtt impl

Signed-off-by: Ruibo Lu <reaperlu@hust.edu.cn>
---
 os/net/app-layer/mqtt/mqtt-prop.c | 849 ++++++++++++++++++++++++++++++
 os/net/app-layer/mqtt/mqtt-prop.h | 138 +++++
 os/net/app-layer/mqtt/mqtt.c      | 767 ++++++++++++++++++++++-----
 os/net/app-layer/mqtt/mqtt.h      | 249 ++++++++-
 4 files changed, 1870 insertions(+), 133 deletions(-)
 create mode 100644 os/net/app-layer/mqtt/mqtt-prop.c
 create mode 100644 os/net/app-layer/mqtt/mqtt-prop.h

diff --git a/os/net/app-layer/mqtt/mqtt-prop.c b/os/net/app-layer/mqtt/mqtt-prop.c
new file mode 100644
index 000000000..881a56bd5
--- /dev/null
+++ b/os/net/app-layer/mqtt/mqtt-prop.c
@@ -0,0 +1,849 @@
+/*
+ * Copyright (c) 2020, Alexandru-Ioan Pop - https://alexandruioan.me
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*---------------------------------------------------------------------------*/
+#include "contiki.h"
+#include "contiki-lib.h"
+#include "lib/memb.h"
+
+#include "mqtt.h"
+#include "mqtt-prop.h"
+
+#include <stdlib.h>
+/*---------------------------------------------------------------------------*/
+#if MQTT_PROP_USE_MEMB
+MEMB(prop_lists_mem, struct mqtt_prop_list, MQTT_PROP_MAX_OUT_PROP_LISTS);
+MEMB(props_mem, struct mqtt_prop_out_property, MQTT_PROP_MAX_OUT_PROPS);
+#endif
+/*----------------------------------------------------------------------------*/
+void
+mqtt_props_init()
+{
+#if MQTT_PROP_USE_MEMB
+  memb_init(&props_mem);
+  memb_init(&prop_lists_mem);
+#endif
+}
+/*----------------------------------------------------------------------------*/
+static void
+encode_prop_fixed_len_int(struct mqtt_prop_out_property **prop_out,
+                          int val, uint8_t len)
+{
+  int8_t i;
+
+  DBG("MQTT - Creating %d-byte int property %i\n", len, val);
+
+  if(len > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return;
+  }
+
+  for(i = len - 1; i >= 0; i--) {
+    (*prop_out)->val[i] = val & 0x00FF;
+    val = val >> 8;
+  }
+
+  (*prop_out)->property_len = len;
+}
+/*---------------------------------------------------------------------------*/
+static void
+encode_prop_utf8(struct mqtt_prop_out_property **prop_out,
+                 const char *str)
+{
+  int str_len;
+
+  DBG("MQTT - Encoding UTF-8 Property %s\n", str);
+  str_len = strlen(str);
+
+  /* 2 bytes are needed for each string to encode its length */
+  if((str_len + 2) > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return;
+  }
+
+  (*prop_out)->val[0] = str_len >> 8;
+  (*prop_out)->val[1] = str_len & 0x00FF;
+  memcpy((*prop_out)->val + 2, str, str_len);
+
+  (*prop_out)->property_len = str_len + 2;
+}
+/*---------------------------------------------------------------------------*/
+static void
+encode_prop_binary(struct mqtt_prop_out_property **prop_out,
+                   const char *data, int data_len)
+{
+  DBG("MQTT - Encoding Binary Data (%d bytes)\n", data_len);
+
+  if((data_len + 2) > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return;
+  }
+
+  (*prop_out)->val[0] = data_len >> 8;
+  (*prop_out)->val[1] = data_len & 0x00FF;
+  memcpy((*prop_out)->val + 2, data, data_len);
+
+  (*prop_out)->property_len = data_len + 2;
+}
+/*---------------------------------------------------------------------------*/
+static void
+encode_prop_var_byte_int(struct mqtt_prop_out_property **prop_out,
+                         int val)
+{
+  uint8_t id_len;
+
+  DBG("MQTT - Encoding Variable Byte Integer %d\n", val);
+
+  mqtt_encode_var_byte_int(
+    (*prop_out)->val,
+    &id_len,
+    val);
+
+  (*prop_out)->property_len = id_len;
+}
+/*---------------------------------------------------------------------------*/
+uint32_t
+mqtt_prop_encode(struct mqtt_prop_out_property **prop_out, mqtt_vhdr_prop_t prop_id,
+                 va_list args)
+{
+  DBG("MQTT - Creating property with ID %i\n", prop_id);
+
+  if(!(*prop_out)) {
+    DBG("MQTT - Error, property target NULL!\n");
+    return 0;
+  }
+
+  (*prop_out)->property_len = 0;
+  (*prop_out)->id = prop_id;
+
+  /* Decode varargs and create encoded property value for selected type */
+  switch(prop_id) {
+  case MQTT_VHDR_PROP_PAYLOAD_FMT_IND:
+  case MQTT_VHDR_PROP_REQ_PROBLEM_INFO:
+  case MQTT_VHDR_PROP_REQ_RESP_INFO: {
+    int val;
+
+    val = va_arg(args, int);
+    encode_prop_fixed_len_int(prop_out, val, 1);
+
+    break;
+  }
+  case MQTT_VHDR_PROP_RECEIVE_MAX:
+  case MQTT_VHDR_PROP_TOPIC_ALIAS_MAX:
+  case MQTT_VHDR_PROP_TOPIC_ALIAS: {
+    int val;
+
+    val = va_arg(args, int);
+    encode_prop_fixed_len_int(prop_out, val, 2);
+
+    break;
+  }
+  case MQTT_VHDR_PROP_MSG_EXP_INT:
+  case MQTT_VHDR_PROP_SESS_EXP_INT:
+  case MQTT_VHDR_PROP_WILL_DELAY_INT:
+  case MQTT_VHDR_PROP_MAX_PKT_SZ: {
+    int val;
+
+    val = va_arg(args, int);
+    encode_prop_fixed_len_int(prop_out, val, 4);
+
+    break;
+  }
+  case MQTT_VHDR_PROP_CONTENT_TYPE:
+  case MQTT_VHDR_PROP_RESP_TOPIC:
+  case MQTT_VHDR_PROP_AUTH_METHOD: {
+    const char *str;
+
+    str = va_arg(args, const char *);
+    encode_prop_utf8(prop_out, str);
+
+    break;
+  }
+  case MQTT_VHDR_PROP_CORRELATION_DATA:
+  case MQTT_VHDR_PROP_AUTH_DATA: {
+    const char *data;
+    int data_len;
+
+    data = va_arg(args, const char *);
+    data_len = va_arg(args, int);
+
+    encode_prop_binary(prop_out, data, data_len);
+
+    break;
+  }
+  case MQTT_VHDR_PROP_SUB_ID: {
+    int val;
+
+    val = va_arg(args, int);
+
+    encode_prop_var_byte_int(prop_out, val);
+
+    break;
+  }
+  case MQTT_VHDR_PROP_USER_PROP: {
+    const char *name;
+    const char *value;
+    uint16_t name_len;
+    uint16_t val_len;
+
+    name = va_arg(args, const char *);
+    value = va_arg(args, const char *);
+
+    name_len = strlen(name);
+    val_len = strlen(value);
+
+    DBG("MQTT - Encoding User Property '%s: %s'\n", name, value);
+
+    /* 2 bytes are needed for each string to encode its length */
+    if((name_len + val_len + 4) > MQTT_PROP_MAX_PROP_LENGTH) {
+      DBG("MQTT - Error, property '%i' too long (max %i bytes)", prop_id, MQTT_PROP_MAX_PROP_LENGTH);
+      return 0;
+    }
+
+    (*prop_out)->val[0] = name_len >> 8;
+    (*prop_out)->val[1] = name_len & 0x00FF;
+    memcpy((*prop_out)->val + 2, name, strlen(name));
+    (*prop_out)->val[name_len + 2] = val_len >> 8;
+    (*prop_out)->val[name_len + 3] = val_len & 0x00FF;
+    memcpy((*prop_out)->val + name_len + 4, value, strlen(value));
+
+    (*prop_out)->property_len = strlen(name) + strlen(value) + 4;
+    break;
+  }
+  default:
+    DBG("MQTT - Error, no such property '%i'\n", prop_id);
+    *prop_out = NULL;
+    return 0;
+  }
+
+  DBG("MQTT - Property encoded length %i\n", (*prop_out)->property_len);
+
+  return (*prop_out)->property_len;
+}
+/*---------------------------------------------------------------------------*/
+#if MQTT_5
+void
+mqtt_prop_decode_input_props(struct mqtt_connection *conn)
+{
+  uint8_t prop_len_bytes;
+
+  DBG("MQTT - Parsing input properties\n");
+
+  /* All but PINGREQ and PINGRESP may contain a set of properties in the VHDR */
+  if(((conn->in_packet.fhdr & 0xF0) == MQTT_FHDR_MSG_TYPE_PINGREQ) ||
+     ((conn->in_packet.fhdr & 0xF0) == MQTT_FHDR_MSG_TYPE_PINGRESP)) {
+    return;
+  }
+
+  DBG("MQTT - Getting length\n");
+
+  prop_len_bytes =
+    mqtt_decode_var_byte_int(conn->in_packet.payload_start,
+                             conn->in_packet.remaining_length - (conn->in_packet.payload_start - conn->in_packet.payload),
+                             NULL, NULL, &conn->in_packet.properties_len);
+
+  if(prop_len_bytes == 0) {
+    DBG("MQTT - Error decoding input properties (out of bounds)\n");
+    return;
+  }
+
+  DBG("MQTT - Received %i VBI property bytes\n", prop_len_bytes);
+  DBG("MQTT - Input properties length %i\n", conn->in_packet.properties_len);
+
+  /* Total property length = number of bytes to encode length + length of
+   * properties themselves
+   */
+  conn->in_packet.properties_enc_len = prop_len_bytes;
+  /* Actual properties start after property length VBI */
+  conn->in_packet.props_start = conn->in_packet.payload_start + prop_len_bytes;
+  conn->in_packet.payload_start += prop_len_bytes;
+  conn->in_packet.curr_props_pos = conn->in_packet.props_start;
+
+  DBG("MQTT - First byte of first prop %i\n", *conn->in_packet.curr_props_pos);
+
+  conn->in_packet.has_props = 1;
+}
+#endif
+/*---------------------------------------------------------------------------*/
+static uint32_t
+decode_prop_utf8(struct mqtt_connection *conn,
+                 uint8_t *buf_in,
+                 uint8_t *data)
+{
+  uint32_t len;
+
+  len = (buf_in[0] << 8) + buf_in[1];
+
+  DBG("MQTT - Decoding %d-char UTF8 string property\n", len);
+
+  /* Include NULL terminator in destination */
+  if((len + MQTT_STRING_LEN_SIZE + 1) > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return 0;
+  }
+
+  memcpy(data, buf_in, len + MQTT_STRING_LEN_SIZE);
+  data[len + MQTT_STRING_LEN_SIZE] = '\0';
+
+  /* Length of string + 2 bytes for length */
+  return len + MQTT_STRING_LEN_SIZE;
+}
+/*---------------------------------------------------------------------------*/
+static uint32_t
+decode_prop_fixed_len_int(struct mqtt_connection *conn,
+                          uint8_t *buf_in, int len,
+                          uint8_t *data)
+{
+  int8_t i;
+  uint32_t *data_out;
+
+  DBG("MQTT - Decoding %d-byte int property\n", len);
+
+  if(len > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return 0;
+  }
+
+  /* All integer input properties will be returned as uint32_t */
+  memset(data, 0, 4);
+
+  data_out = (uint32_t *)data;
+
+  for(i = 0; i < 4; i++) {
+    *data_out = *data_out << 8;
+
+    if(i < len) {
+      *data_out += buf_in[i];
+    }
+  }
+
+  return len;
+}
+/*---------------------------------------------------------------------------*/
+static uint32_t
+decode_prop_vbi(struct mqtt_connection *conn,
+                uint8_t *buf_in,
+                uint8_t *data)
+{
+  uint8_t prop_len_bytes;
+
+  DBG("MQTT - Decoding Variable Byte Integer property\n");
+
+  /* All integer input properties will be returned as uint32_t */
+  memset(data, 0, 4);
+
+  prop_len_bytes =
+    mqtt_decode_var_byte_int(buf_in, 4, NULL, NULL, (uint16_t *)data);
+
+  if(prop_len_bytes == 0) {
+    DBG("MQTT - Error decoding Variable Byte Integer\n");
+    return 0;
+  }
+
+  if(prop_len_bytes > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return 0;
+  }
+
+  return prop_len_bytes;
+}
+/*---------------------------------------------------------------------------*/
+static uint32_t
+decode_prop_binary_data(struct mqtt_connection *conn,
+                        uint8_t *buf_in,
+                        uint8_t *data)
+{
+  uint8_t data_len;
+
+  DBG("MQTT - Decoding Binary Data property\n");
+
+  data_len = (buf_in[0] << 8) + buf_in[1];
+
+  if(data_len == 0) {
+    DBG("MQTT - Error decoding Binary Data property length\n");
+    return 0;
+  }
+
+  if((data_len + 2) > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return 0;
+  }
+
+  memcpy(data, buf_in, data_len + 2);
+
+  return data_len + 2;
+}
+/*---------------------------------------------------------------------------*/
+static uint32_t
+decode_prop_utf8_pair(struct mqtt_connection *conn,
+                      uint8_t *buf_in,
+                      uint8_t *data)
+{
+  uint32_t len1;
+  uint32_t len2;
+  uint32_t total_len;
+
+  len1 = (buf_in[0] << 8) + buf_in[1];
+  len2 = (buf_in[len1 + MQTT_STRING_LEN_SIZE] << 8) + buf_in[len1 + MQTT_STRING_LEN_SIZE + 1];
+  total_len = len1 + len2;
+
+  DBG("MQTT - Decoding %d-char UTF8 string pair property (%i + %i)\n", total_len, len1, len2);
+
+  if((total_len + 2 * MQTT_STRING_LEN_SIZE) > MQTT_PROP_MAX_PROP_LENGTH) {
+    DBG("MQTT - Error, property too long (max %i bytes)", MQTT_PROP_MAX_PROP_LENGTH);
+    return 0;
+  }
+
+  memcpy(data, buf_in, total_len + 2 * MQTT_STRING_LEN_SIZE);
+
+  /* Length of string + 2 bytes for length */
+  return total_len + 2 * MQTT_STRING_LEN_SIZE;
+}
+/*---------------------------------------------------------------------------*/
+uint32_t
+parse_prop(struct mqtt_connection *conn,
+           mqtt_vhdr_prop_t prop_id, uint8_t *buf_in, uint8_t *data)
+{
+  switch(prop_id) {
+  case MQTT_VHDR_PROP_PAYLOAD_FMT_IND:
+  case MQTT_VHDR_PROP_REQ_PROBLEM_INFO:
+  case MQTT_VHDR_PROP_REQ_RESP_INFO:
+  case MQTT_VHDR_PROP_MAX_QOS:
+  case MQTT_VHDR_PROP_RETAIN_AVAIL:
+  case MQTT_VHDR_PROP_WILD_SUB_AVAIL:
+  case MQTT_VHDR_PROP_SUB_ID_AVAIL:
+  case MQTT_VHDR_PROP_SHARED_SUB_AVAIL: {
+    return decode_prop_fixed_len_int(conn, buf_in, 1, data);
+  }
+  case MQTT_VHDR_PROP_RECEIVE_MAX:
+  case MQTT_VHDR_PROP_TOPIC_ALIAS_MAX:
+  case MQTT_VHDR_PROP_SERVER_KEEP_ALIVE: {
+    return decode_prop_fixed_len_int(conn, buf_in, 2, data);
+  }
+  case MQTT_VHDR_PROP_MSG_EXP_INT:
+  case MQTT_VHDR_PROP_SESS_EXP_INT:
+  case MQTT_VHDR_PROP_WILL_DELAY_INT:
+  case MQTT_VHDR_PROP_MAX_PKT_SZ: {
+    return decode_prop_fixed_len_int(conn, buf_in, 4, data);
+  }
+  case MQTT_VHDR_PROP_CONTENT_TYPE:
+  case MQTT_VHDR_PROP_RESP_TOPIC:
+  case MQTT_VHDR_PROP_AUTH_METHOD:
+  case MQTT_VHDR_PROP_ASSIGNED_CLIENT_ID:
+  case MQTT_VHDR_PROP_RESP_INFO:
+  case MQTT_VHDR_PROP_SERVER_REFERENCE:
+  case MQTT_VHDR_PROP_REASON_STRING: {
+    return decode_prop_utf8(conn, buf_in, data);
+  }
+  case MQTT_VHDR_PROP_CORRELATION_DATA:
+  case MQTT_VHDR_PROP_AUTH_DATA: {
+    return decode_prop_binary_data(conn, buf_in, data);
+  }
+  case MQTT_VHDR_PROP_SUB_ID: {
+    return decode_prop_vbi(conn, buf_in, data);
+  }
+  case MQTT_VHDR_PROP_USER_PROP: {
+    return decode_prop_utf8_pair(conn, buf_in, data);
+  }
+  default:
+    DBG("MQTT - Error, no such property '%i'", prop_id);
+    return 0;
+  }
+
+  return 0;
+}
+/*---------------------------------------------------------------------------*/
+#if MQTT_5
+uint32_t
+mqtt_get_next_in_prop(struct mqtt_connection *conn,
+                      mqtt_vhdr_prop_t *prop_id, uint8_t *data)
+{
+  uint32_t prop_len;
+  uint8_t prop_id_len_bytes;
+  uint16_t prop_id_decode;
+
+  if(!conn->in_packet.has_props) {
+    DBG("MQTT - Message has no input properties");
+    return 0;
+  }
+
+  DBG("MQTT - Curr prop pos %i; len %i; byte %i\n", (conn->in_packet.curr_props_pos - conn->in_packet.props_start),
+      conn->in_packet.properties_len,
+      *conn->in_packet.curr_props_pos);
+
+  if((conn->in_packet.curr_props_pos - conn->in_packet.props_start)
+     >= conn->in_packet.properties_len) {
+    DBG("MQTT - Message has no more input properties\n");
+    return 0;
+  }
+
+  prop_id_len_bytes =
+    mqtt_decode_var_byte_int(conn->in_packet.curr_props_pos,
+                             conn->in_packet.properties_len - (conn->in_packet.curr_props_pos - conn->in_packet.props_start),
+                             NULL, NULL, (uint16_t *)&prop_id_decode);
+
+  *prop_id = prop_id_decode;
+
+  DBG("MQTT - Decoded property ID %i (encoded using %i bytes)\n", *prop_id, prop_id_len_bytes);
+
+  prop_len = parse_prop(conn, *prop_id, conn->in_packet.curr_props_pos + 1, data);
+
+  DBG("MQTT - Decoded property len %i bytes\n", prop_len);
+
+  conn->in_packet.curr_props_pos += prop_id_len_bytes + prop_len;
+
+  return prop_len;
+}
+/*---------------------------------------------------------------------------*/
+void
+mqtt_prop_parse_connack_props(struct mqtt_connection *conn)
+{
+  uint32_t prop_len;
+  mqtt_vhdr_prop_t prop_id;
+  uint8_t data[MQTT_PROP_MAX_PROP_LENGTH];
+  uint32_t val_int;
+
+  DBG("MQTT - Parsing CONNACK properties for server capabilities\n");
+
+  prop_len = mqtt_get_next_in_prop(conn, &prop_id, data);
+  while(prop_len) {
+    switch(prop_id) {
+    case MQTT_VHDR_PROP_RETAIN_AVAIL: {
+      val_int = (uint32_t)*data;
+      if(val_int == 0) {
+        conn->srv_feature_en &= ~MQTT_CAP_RETAIN_AVAIL;
+      }
+      break;
+    }
+    case MQTT_VHDR_PROP_WILD_SUB_AVAIL: {
+      val_int = (uint32_t)*data;
+      if(val_int == 0) {
+        conn->srv_feature_en &= ~MQTT_CAP_WILD_SUB_AVAIL;
+      }
+      break;
+    }
+    case MQTT_VHDR_PROP_SUB_ID_AVAIL: {
+      val_int = (uint32_t)*data;
+      if(val_int == 0) {
+        conn->srv_feature_en &= ~MQTT_CAP_SUB_ID_AVAIL;
+      }
+      break;
+    }
+    case MQTT_VHDR_PROP_SHARED_SUB_AVAIL:  {
+      val_int = (uint32_t)*data;
+      if(val_int == 0) {
+        conn->srv_feature_en &= ~MQTT_CAP_SHARED_SUB_AVAIL;
+      }
+      break;
+    }
+    default:
+      DBG("MQTT - Error, unexpected CONNACK property '%i'", prop_id);
+      return;
+    }
+
+    prop_id = 0;
+    prop_len = mqtt_get_next_in_prop(conn, &prop_id, data);
+  }
+}
+/*---------------------------------------------------------------------------*/
+void
+mqtt_prop_parse_auth_props(struct mqtt_connection *conn, struct mqtt_prop_auth_event *event)
+{
+  uint32_t prop_len;
+  mqtt_vhdr_prop_t prop_id;
+  uint8_t data[MQTT_PROP_MAX_PROP_LENGTH];
+
+  DBG("MQTT - Parsing CONNACK properties for server capabilities\n");
+
+  event->auth_data.len = 0;
+  event->auth_method.length = 0;
+
+  prop_len = mqtt_get_next_in_prop(conn, &prop_id, data);
+  while(prop_len) {
+    switch(prop_id) {
+    case MQTT_VHDR_PROP_AUTH_DATA: {
+      event->auth_data.len = prop_len - 2; /* 2 bytes are used to encode len */
+      memcpy(event->auth_data.data, data, prop_len - 2);
+      break;
+    }
+    case MQTT_VHDR_PROP_AUTH_METHOD: {
+      event->auth_method.length = prop_len - 2; /* 2 bytes are used to encode len */
+      memcpy(event->auth_method.string, data, prop_len - 2);
+      break;
+    }
+    default:
+      DBG("MQTT - Unhandled AUTH property '%i'", prop_id);
+      return;
+    }
+
+    prop_id = 0;
+    prop_len = mqtt_get_next_in_prop(conn, &prop_id, data);
+  }
+}
+/*---------------------------------------------------------------------------*/
+void
+mqtt_prop_print_input_props(struct mqtt_connection *conn)
+{
+  uint32_t prop_len;
+  mqtt_vhdr_prop_t prop_id;
+  uint8_t data[MQTT_PROP_MAX_PROP_LENGTH];
+  uint32_t i;
+
+  DBG("MQTT - Printing all input properties\n");
+
+  prop_len = mqtt_get_next_in_prop(conn, &prop_id, data);
+  while(prop_len) {
+    DBG("MQTT - Property ID %i, length %i\n", prop_id, prop_len);
+
+    switch(prop_id) {
+    case MQTT_VHDR_PROP_PAYLOAD_FMT_IND:
+    case MQTT_VHDR_PROP_REQ_PROBLEM_INFO:
+    case MQTT_VHDR_PROP_REQ_RESP_INFO:
+    case MQTT_VHDR_PROP_MSG_EXP_INT:
+    case MQTT_VHDR_PROP_SESS_EXP_INT:
+    case MQTT_VHDR_PROP_WILL_DELAY_INT:
+    case MQTT_VHDR_PROP_MAX_PKT_SZ:
+    case MQTT_VHDR_PROP_RECEIVE_MAX:
+    case MQTT_VHDR_PROP_TOPIC_ALIAS_MAX:
+    case MQTT_VHDR_PROP_SUB_ID: {
+      DBG("MQTT - Decoded property value '%i'\n", (uint32_t)*data);
+      break;
+    }
+    case MQTT_VHDR_PROP_CONTENT_TYPE:
+    case MQTT_VHDR_PROP_RESP_TOPIC:
+    case MQTT_VHDR_PROP_AUTH_METHOD: {
+      DBG("MQTT - Decoded property value ");
+      DBG("(%i %i) %s", data[0], data[1], data + MQTT_STRING_LEN_SIZE);
+      DBG("\n");
+      break;
+    }
+    case MQTT_VHDR_PROP_CORRELATION_DATA:
+    case MQTT_VHDR_PROP_AUTH_DATA: {
+      DBG("MQTT - Decoded property value (%i %i) ", data[0], data[1]);
+      for(i = 2; i < prop_len; i++) {
+        DBG("%x ", data[i]);
+      }
+      DBG("\n");
+      break;
+    }
+    case MQTT_VHDR_PROP_USER_PROP: {
+#if DEBUG_MQTT
+      uint32_t len1;
+      uint32_t len2;
+
+      len1 = (data[0] << 8) + data[1];
+      len2 = (data[len1 + MQTT_STRING_LEN_SIZE] << 8) + data[len1 + MQTT_STRING_LEN_SIZE + 1];
+#endif
+      DBG("MQTT - Decoded property value [(%i %i) %.*s, (%i %i) %.*s]",
+          data[0], data[1], len1, data + MQTT_STRING_LEN_SIZE,
+          data[len1 + MQTT_STRING_LEN_SIZE], data[len1 + MQTT_STRING_LEN_SIZE + 1], len2, data + len1 + 2 * MQTT_STRING_LEN_SIZE);
+      DBG("\n");
+      break;
+    }
+    default:
+      DBG("MQTT - Error, no such property '%i'\n", prop_id);
+      return;
+    }
+
+    prop_id = 0;
+    prop_len = mqtt_get_next_in_prop(conn, &prop_id, data);
+  }
+}
+/*
+ * Functions to manipulate property lists
+ */
+/*----------------------------------------------------------------------------*/
+/* Creates a property list for the requested message type */
+void
+mqtt_prop_create_list(struct mqtt_prop_list **prop_list_out)
+{
+  DBG("MQTT - Creating Property List\n");
+
+#if MQTT_PROP_USE_MEMB
+  *prop_list_out = memb_alloc(&prop_lists_mem);
+#endif
+
+  if(!(*prop_list_out)) {
+    DBG("MQTT - Error, allocated too many property lists (max %i)\n", MQTT_PROP_MAX_OUT_PROP_LISTS);
+    return;
+  }
+
+  DBG("MQTT - Allocated Property list\n");
+
+  LIST_STRUCT_INIT(*prop_list_out, props);
+
+  DBG("MQTT - mem %p prop_list\n", *prop_list_out);
+
+  (*prop_list_out)->properties_len = 0;
+  (*prop_list_out)->properties_len_enc_bytes = 1; /* 1 byte needed for len = 0 */
+}
+/*----------------------------------------------------------------------------*/
+/* Prints all properties in the given property list (debug)
+ * If ID == MQTT_VHDR_PROP_ANY, prints all properties, otherwise it filters them
+ * by property ID
+ */
+void
+mqtt_prop_print_list(struct mqtt_prop_list *prop_list, mqtt_vhdr_prop_t prop_id)
+{
+  struct mqtt_prop_out_property *prop;
+
+  if(prop_list == NULL || prop_list->props == NULL) {
+    DBG("MQTT - Prop list empty\n");
+  } else {
+    prop = (struct mqtt_prop_out_property *)list_head(prop_list->props);
+
+    do {
+      if(prop != NULL && (prop->id == prop_id || prop_id == MQTT_VHDR_PROP_ANY)) {
+        DBG("Property %p ID %i len %i\n", prop, prop->id, prop->property_len);
+      }
+      prop = (struct mqtt_prop_out_property *)list_item_next(prop);
+    } while(prop != NULL);
+  }
+}
+/*---------------------------------------------------------------------------*/
+uint8_t
+mqtt_prop_register_internal(struct mqtt_prop_list **prop_list,
+#if !MQTT_PROP_USE_MEMB
+                            struct mqtt_prop_out_property *prop,
+#endif
+                            mqtt_msg_type_t msg,
+                            mqtt_vhdr_prop_t prop_id,
+                            struct mqtt_prop_out_property **prop_out, ...)
+{
+  /* check that the property is compatible with the message? */
+  if(!prop_list) {
+    DBG("MQTT - Error encoding prop %i on msg %i; list NULL\n", prop_id, msg);
+    return 1;
+  }
+
+  DBG("MQTT - prop list %p\n", *prop_list);
+  DBG("MQTT - prop list->list %p\n", (*prop_list)->props);
+
+#if MQTT_PROP_USE_MEMB
+  struct mqtt_prop_out_property *prop = memb_alloc(&props_mem);
+#endif
+
+  if(!prop) {
+    DBG("MQTT - Error, allocated too many properties (max %i)\n", MQTT_PROP_MAX_OUT_PROPS);
+    prop_out = NULL;
+    return 1;
+  }
+
+  DBG("MQTT - Allocated prop %p\n", prop);
+
+  va_list args;
+  va_start(args, prop_out);
+  uint32_t prop_len = mqtt_prop_encode(&prop, prop_id, args);
+
+  if(prop) {
+    DBG("MQTT - Adding prop %p to prop_list %p\n", prop, *prop_list);
+    list_add((*prop_list)->props, prop);
+    (*prop_list)->properties_len += 1; /* Property ID */
+    (*prop_list)->properties_len += prop_len;
+    mqtt_encode_var_byte_int(
+      (*prop_list)->properties_len_enc,
+      &((*prop_list)->properties_len_enc_bytes),
+      (*prop_list)->properties_len);
+    DBG("MQTT - New prop_list length %i\n", (*prop_list)->properties_len);
+  } else {
+    DBG("MQTT - Error encoding prop %i on msg %i\n", prop_id, msg);
+#if MQTT_PROP_USE_MEMB
+    memb_free(&props_mem, prop);
+#endif
+    va_end(args);
+    prop_out = NULL;
+    return 1;
+  }
+
+  if(prop_out) {
+    *prop_out = prop;
+  }
+  va_end(args);
+  return 0;
+}
+/*----------------------------------------------------------------------------*/
+/* Remove one property from list and free its memory */
+uint8_t
+mqtt_remove_prop(struct mqtt_prop_list **prop_list,
+                 struct mqtt_prop_out_property *prop)
+{
+  if(prop != NULL && prop_list != NULL && list_contains((*prop_list)->props, prop)) {
+    DBG("MQTT - Removing property %p from list %p\n", prop, *prop_list);
+
+    /* Remove from list */
+    list_remove((*prop_list)->props, prop);
+
+    /* Fix the property list length */
+    (*prop_list)->properties_len -= prop->property_len;
+    (*prop_list)->properties_len -= 1; /* Property ID */
+
+    mqtt_encode_var_byte_int(
+      (*prop_list)->properties_len_enc,
+      &((*prop_list)->properties_len_enc_bytes),
+      (*prop_list)->properties_len);
+
+    /* Free memory */
+#if MQTT_PROP_USE_MEMB
+    memb_free(&props_mem, prop);
+#endif
+    return 0;
+  } else {
+    DBG("MQTT - Cannot remove property\n");
+    return 1;
+  }
+}
+/* Remove & frees all properties in the list */
+void
+mqtt_prop_clear_list(struct mqtt_prop_list **prop_list)
+{
+  struct mqtt_prop_out_property *prop;
+
+  DBG("MQTT - Clearing Property List\n");
+
+  if(prop_list == NULL || list_length((*prop_list)->props) == 0) {
+    DBG("MQTT - Prop list empty\n");
+    return;
+  } else {
+    prop = (struct mqtt_prop_out_property *)list_head((*prop_list)->props);
+
+    do {
+      if(prop != NULL) {
+        (void)mqtt_remove_prop(prop_list, prop);
+      }
+      prop = (struct mqtt_prop_out_property *)list_head((*prop_list)->props);
+    } while(prop != NULL);
+  }
+
+  LIST_STRUCT_INIT(*prop_list, props);
+
+  if((*prop_list)->properties_len != 0 || (*prop_list)->properties_len_enc_bytes != 1) {
+    DBG("MQTT - Something went wrong when clearing property list!\n");
+  }
+}
+#endif
diff --git a/os/net/app-layer/mqtt/mqtt-prop.h b/os/net/app-layer/mqtt/mqtt-prop.h
new file mode 100644
index 000000000..676d3776f
--- /dev/null
+++ b/os/net/app-layer/mqtt/mqtt-prop.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2020, Alexandru-Ioan Pop - https://alexandruioan.me
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*---------------------------------------------------------------------------*/
+#ifndef MQTT_PROP_H_
+#define MQTT_PROP_H_
+/*---------------------------------------------------------------------------*/
+#include "mqtt.h"
+
+#include <stdarg.h>
+/*---------------------------------------------------------------------------*/
+/* If not using memb, you must provide a pointer to
+ * statically-allocated memory to register_prop()
+ */
+#ifdef MQTT_PROP_CONF_PROP_USE_MEMB
+#define MQTT_PROP_USE_MEMB MQTT_PROP_CONF_PROP_USE_MEMB
+#else
+#define MQTT_PROP_USE_MEMB 1
+#endif
+/*---------------------------------------------------------------------------*/
+/* Number of output property lists */
+#define MQTT_PROP_MAX_OUT_PROP_LISTS 1
+
+/* Number of output properties that will be declared, regardless of
+ * message type
+ */
+#define MQTT_PROP_MAX_OUT_PROPS 2
+
+/* Max length of 1 property in bytes */
+#define MQTT_PROP_MAX_PROP_LENGTH     32
+/* Max number of bytes in Variable Byte Integer representation of
+ * total property length
+ */
+#define MQTT_PROP_MAX_PROP_LEN_BYTES   2
+/* Max number of topic aliases (when receiving) */
+#define MQTT_PROP_MAX_NUM_TOPIC_ALIASES 1
+
+#define MQTT_PROP_LIST_NONE NULL
+/*----------------------------------------------------------------------------*/
+struct mqtt_prop_list {
+  /* Total length of properties */
+  uint32_t properties_len;
+  uint8_t properties_len_enc[MQTT_PROP_MAX_PROP_LEN_BYTES];
+  uint8_t properties_len_enc_bytes;
+  LIST_STRUCT(props);
+};
+
+/* This struct represents output packet Properties (MQTTv5.0). */
+struct mqtt_prop_out_property {
+  /* Used by the list interface, must be first in the struct. */
+  struct mqtt_prop_out_property *next;
+
+  /* Property identifier (as an MQTT Variable Byte Integer)
+   * The maximum ID is currently 0x2A so 1 byte is sufficient
+   * (the range of 1 VBI byte is 0x00 - 0x7F)
+   */
+  mqtt_vhdr_prop_t id;
+  /* Property length */
+  uint32_t property_len;
+  /* Property value */
+  uint8_t val[MQTT_PROP_MAX_PROP_LENGTH];
+};
+
+struct mqtt_prop_bin_data {
+  uint16_t len;
+  uint8_t data[MQTT_PROP_MAX_PROP_LENGTH];
+};
+
+struct mqtt_prop_auth_event {
+  struct mqtt_string auth_method;
+  struct mqtt_prop_bin_data auth_data;
+};
+/*----------------------------------------------------------------------------*/
+void mqtt_prop_print_input_props(struct mqtt_connection *conn);
+
+uint32_t mqtt_prop_encode(struct mqtt_prop_out_property **prop_out, mqtt_vhdr_prop_t prop_id,
+                          va_list args);
+
+void mqtt_prop_parse_connack_props(struct mqtt_connection *conn);
+
+void mqtt_prop_parse_auth_props(struct mqtt_connection *conn, struct mqtt_prop_auth_event *event);
+
+void mqtt_prop_decode_input_props(struct mqtt_connection *conn);
+
+/* Switch argument order to avoid undefined behavior from having a type
+   that undergoes argument promotion immediately before ", ...". */
+#if MQTT_PROP_USE_MEMB
+#define mqtt_prop_register(l, out, msg, id, ...) \
+  mqtt_prop_register_internal(l, msg, id, out, __VA_ARGS__)
+#else
+#define mqtt_prop_register(l, prop, out, msg, id, ...)           \
+  mqtt_prop_register_internal(l, prop, msg, id, out, __VA_ARGS__)
+#endif /* MQTT_PROP_USE_MEMB */
+
+uint8_t mqtt_prop_register_internal(struct mqtt_prop_list **prop_list,
+#if !MQTT_PROP_USE_MEMB
+                                    struct mqtt_prop_out_property *prop,
+#endif
+                                    mqtt_msg_type_t msg,
+                                    mqtt_vhdr_prop_t prop_id,
+                                    struct mqtt_prop_out_property **prop_out, ...);
+
+void mqtt_prop_create_list(struct mqtt_prop_list **prop_list_out);
+
+void mqtt_prop_print_list(struct mqtt_prop_list *prop_list, mqtt_vhdr_prop_t prop_id);
+
+void mqtt_prop_clear_list(struct mqtt_prop_list **prop_list);
+
+void mqtt_props_init();
+/*---------------------------------------------------------------------------*/
+#endif /* MQTT_PROP_H_ */
+/*---------------------------------------------------------------------------*/
diff --git a/os/net/app-layer/mqtt/mqtt.c b/os/net/app-layer/mqtt/mqtt.c
index 2dad5ce0c..d93a27b0a 100644
--- a/os/net/app-layer/mqtt/mqtt.c
+++ b/os/net/app-layer/mqtt/mqtt.c
@@ -41,6 +41,7 @@
  */
 /*---------------------------------------------------------------------------*/
 #include "mqtt.h"
+#include "mqtt-prop.h"
 #include "contiki.h"
 #include "contiki-net.h"
 #include "contiki-lib.h"
@@ -61,6 +62,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <stdarg.h>
 /*---------------------------------------------------------------------------*/
 #define DEBUG 0
 #if DEBUG
@@ -70,21 +72,6 @@
 #endif
 /*---------------------------------------------------------------------------*/
 typedef enum {
-  MQTT_FHDR_MSG_TYPE_CONNECT       = 0x10,
-  MQTT_FHDR_MSG_TYPE_CONNACK       = 0x20,
-  MQTT_FHDR_MSG_TYPE_PUBLISH       = 0x30,
-  MQTT_FHDR_MSG_TYPE_PUBACK        = 0x40,
-  MQTT_FHDR_MSG_TYPE_PUBREC        = 0x50,
-  MQTT_FHDR_MSG_TYPE_PUBREL        = 0x60,
-  MQTT_FHDR_MSG_TYPE_PUBCOMP       = 0x70,
-  MQTT_FHDR_MSG_TYPE_SUBSCRIBE     = 0x80,
-  MQTT_FHDR_MSG_TYPE_SUBACK        = 0x90,
-  MQTT_FHDR_MSG_TYPE_UNSUBSCRIBE   = 0xA0,
-  MQTT_FHDR_MSG_TYPE_UNSUBACK      = 0xB0,
-  MQTT_FHDR_MSG_TYPE_PINGREQ       = 0xC0,
-  MQTT_FHDR_MSG_TYPE_PINGRESP      = 0xD0,
-  MQTT_FHDR_MSG_TYPE_DISCONNECT    = 0xE0,
-
   MQTT_FHDR_DUP_FLAG               = 0x08,
 
   MQTT_FHDR_QOS_LEVEL_0            = 0x00,
@@ -104,7 +91,7 @@ typedef enum {
   MQTT_VHDR_WILL_QOS_LEVEL_2   = 0x10,
 
   MQTT_VHDR_WILL_FLAG          = 0x04,
-  MQTT_VHDR_CLEAN_SESSION_FLAG = 0x02,
+  MQTT_VHDR_CLEAN_SESSION_FLAG = 0x02, /* called Clean Start in MQTTv5.0 */
 } mqtt_vhdr_conn_fields_t;
 /*---------------------------------------------------------------------------*/
 typedef enum {
@@ -121,48 +108,60 @@ typedef enum {
 } mqtt_vhdr_connack_flags_t;
 
 /*---------------------------------------------------------------------------*/
-#if MQTT_311
 typedef enum {
   MQTT_SUBACK_RET_QOS_0 = 0x00,
   MQTT_SUBACK_RET_QOS_1 = 0x01,
   MQTT_SUBACK_RET_QOS_2 = 0x02,
   MQTT_SUBACK_RET_FAIL  = 0x08,
 } mqtt_suback_ret_code_t;
-#endif
 /*---------------------------------------------------------------------------*/
-#if MQTT_31
-/* Len MSB(0)
- * Len LSB(6)
- * 'M'
- * 'Q'
- * 'I'
- * 's'
- * 'd'
- * 'p'
- * Protocol Level (3)
- * Connect Flags
- * Keep Alive MSB
- * Keep Alive LSB
- */
-#define MQTT_CONNECT_VHDR_SIZE 12
-#else
-/* Len MSB(0)
- * Len LSB(4)
- * 'M'
- * 'Q'
- * 'T'
- * 'T'
- * Protocol Level (4)
- * Connect Flags
- * Keep Alive MSB
- * Keep Alive LSB
- */
-#define MQTT_CONNECT_VHDR_SIZE 10
-#endif
-
-#define MQTT_STRING_LEN_SIZE 2
-#define MQTT_MID_SIZE 2
-#define MQTT_QOS_SIZE 1
+/* MQTTv5.0 Reason Codes */
+typedef enum {
+  MQTT_VHDR_RC_SUCCES_OR_NORMAL       = 0x00,
+  MQTT_VHDR_RC_QOS_0                  = 0x01,
+  MQTT_VHDR_RC_QOS_1                  = 0x02,
+  MQTT_VHDR_RC_QOS_2                  = 0x03,
+  MQTT_VHDR_RC_DISC_WITH_WILL         = 0x04,
+  MQTT_VHDR_RC_NO_MATCH_SUB           = 0x10,
+  MQTT_VHDR_RC_NO_SUB_EXISTED         = 0x11,
+  MQTT_VHDR_RC_CONTINUE_AUTH          = 0x18,
+  MQTT_VHDR_RC_REAUTH                 = 0x19,
+  MQTT_VHDR_RC_UNSPEC_ERR             = 0x80,
+  MQTT_VHDR_RC_MALFORMED_PKT          = 0x81,
+  MQTT_VHDR_RC_PROTOCOL_ERR           = 0x82,
+  MQTT_VHDR_RC_IMPL_SPEC_ERR          = 0x83,
+  MQTT_VHDR_RC_PROT_VER_UNUSUPPORTED  = 0x84,
+  MQTT_VHDR_RC_CLIENT_ID_INVALID      = 0x85,
+  MQTT_VHDR_RC_BAD_USER_PASS          = 0x86,
+  MQTT_VHDR_RC_NOT_AUTH               = 0x87,
+  MQTT_VHDR_RC_SRV_UNAVAIL            = 0x88,
+  MQTT_VHDR_RC_SRV_BUSY               = 0x89,
+  MQTT_VHDR_RC_BANNED                 = 0x8A,
+  MQTT_VHDR_RC_SRV_SHUTDOWN           = 0x8B,
+  MQTT_VHDR_RC_BAD_AUTH_METHOD        = 0x8C,
+  MQTT_VHDR_RC_KEEP_ALIVE_TIMEOUT     = 0x8D,
+  MQTT_VHDR_RC_SESS_TAKEN_OVER        = 0x8E,
+  MQTT_VHDR_RC_TOPIC_FILT_INVAL       = 0x8F,
+  MQTT_VHDR_RC_TOPIC_NAME_INVAL       = 0x90,
+  MQTT_VHDR_RC_PKT_ID_IN_USE          = 0x91,
+  MQTT_VHDR_RC_PKT_ID_NOT_FOUND       = 0x92,
+  MQTT_VHDR_RC_RECV_MAX_EXCEEDED      = 0x93,
+  MQTT_VHDR_RC_TOPIC_ALIAS_INVAL      = 0x94,
+  MQTT_VHDR_RC_PKT_TOO_LARGE          = 0x95,
+  MQTT_VHDR_RC_MSG_RATE_TOO_HIGH      = 0x96,
+  MQTT_VHDR_RC_QUOTA_EXCEEDED         = 0x97,
+  MQTT_VHDR_RC_ADMIN_ACTION           = 0x98,
+  MQTT_VHDR_RC_PAYLD_FMT_INVAL        = 0x99,
+  MQTT_VHDR_RC_RETAIN_UNSUPPORTED     = 0x9A,
+  MQTT_VHDR_RC_QOS_UNSUPPORTED        = 0x9B,
+  MQTT_VHDR_RC_USE_ANOTHER_SRV        = 0x9C,
+  MQTT_VHDR_RC_SRV_MOVED              = 0x9D,
+  MQTT_VHDR_RC_SHARED_SUB_UNSUPPORTED = 0x9E,
+  MQTT_VHDR_RC_CONN_RATE_EXCEEDED     = 0x9F,
+  MQTT_VHDR_RC_MAX_CONN_TIME          = 0xA0,
+  MQTT_VHDR_RC_SUB_ID_UNSUPPORTED     = 0xA1,
+  MQTT_VHDR_RC_WILD_SUB_UNSUPPORTED   = 0xA2,
+} mqtt_reason_code_t;
 /*---------------------------------------------------------------------------*/
 #define RESPONSE_WAIT_TIMEOUT (CLOCK_SECOND * 10)
 /*---------------------------------------------------------------------------*/
@@ -213,6 +212,7 @@ static process_event_t mqtt_do_publish_event;
 static process_event_t mqtt_do_pingreq_event;
 static process_event_t mqtt_continue_send_event;
 static process_event_t mqtt_abort_now_event;
+static process_event_t mqtt_do_auth_event;
 process_event_t mqtt_update_event;
 
 /*
@@ -361,7 +361,7 @@ write_bytes(struct mqtt_connection *conn, uint8_t *data, uint16_t len)
   conn->out_write_pos += write_bytes;
   conn->out_buffer_ptr += write_bytes;
 
-  DBG("MQTT - (write_bytes) len: %u write_pos: %lu\n", len,
+  DBG("MQTT - (write_bytes) len: %u write_pos: %i\n", len,
       conn->out_write_pos);
 
   if(len - conn->out_write_pos == 0) {
@@ -373,28 +373,69 @@ write_bytes(struct mqtt_connection *conn, uint8_t *data, uint16_t len)
   }
 }
 /*---------------------------------------------------------------------------*/
-static void
-encode_remaining_length(uint8_t *remaining_length,
-                        uint8_t *remaining_length_bytes,
-                        uint32_t length)
+uint8_t
+mqtt_decode_var_byte_int(const uint8_t *input_data_ptr,
+                         int input_data_len,
+                         uint32_t *input_pos,
+                         uint32_t *pkt_byte_count,
+                         uint16_t *dest)
+{
+  uint8_t read_bytes = 0;
+  uint8_t byte_in;
+  uint8_t multiplier = 1;
+  uint32_t input_pos_0 = 0;
+
+  if(input_pos == NULL) {
+    input_pos = &input_pos_0;
+  }
+
+  do {
+    if(*input_pos >= input_data_len) {
+      return 0;
+    }
+
+    byte_in = input_data_ptr[*input_pos];
+    (*input_pos)++;
+    if(pkt_byte_count) {
+      (*pkt_byte_count)++;
+    }
+    read_bytes++;
+    DBG("MQTT - Read Variable Byte Integer byte %i\n", byte_in);
+
+    if(read_bytes > 4) {
+      DBG("Received more than 4 byte 'Variable Byte Integer'.");
+      return 0;
+    }
+
+    *dest += (byte_in & 127) * multiplier;
+    multiplier *= 128;
+  } while((byte_in & 128) != 0);
+
+  return read_bytes;
+}
+/*---------------------------------------------------------------------------*/
+void
+mqtt_encode_var_byte_int(uint8_t *vbi_out,
+                         uint8_t *vbi_bytes,
+                         uint32_t val)
 {
   uint8_t digit;
 
-  DBG("MQTT - Encoding length %lu\n", length);
+  DBG("MQTT - Encoding Variable Byte Integer %u\n", val);
 
-  *remaining_length_bytes = 0;
+  *vbi_bytes = 0;
   do {
-    digit = length % 128;
-    length = length / 128;
-    if(length > 0) {
+    digit = val % 128;
+    val = val / 128;
+    if(val > 0) {
       digit = digit | 0x80;
     }
 
-    remaining_length[*remaining_length_bytes] = digit;
-    (*remaining_length_bytes)++;
-    DBG("MQTT - Encode len digit '%u' length '%lu'\n", digit, length);
-  } while(length > 0 && *remaining_length_bytes < 5);
-  DBG("MQTT - remaining_length_bytes %u\n", *remaining_length_bytes);
+    vbi_out[*vbi_bytes] = digit;
+    (*vbi_bytes)++;
+    DBG("MQTT - Encode VBI digit '%u' length '%i'\n", digit, val);
+  } while(val > 0 && *vbi_bytes < 5);
+  DBG("MQTT - var_byte_int bytes %u\n", *vbi_bytes);
 }
 /*---------------------------------------------------------------------------*/
 static void
@@ -418,14 +459,57 @@ static void
 reset_packet(struct mqtt_in_packet *packet)
 {
   memset(packet, 0, sizeof(struct mqtt_in_packet));
-  packet->remaining_multiplier = 1;
 }
 /*---------------------------------------------------------------------------*/
+#if MQTT_5
+static
+PT_THREAD(write_out_props(struct pt *pt, struct mqtt_connection *conn,
+                          struct mqtt_prop_list *prop_list))
+{
+  PT_BEGIN(pt);
+
+  static struct mqtt_prop_out_property *prop;
+
+  if(prop_list) {
+    DBG("MQTT - Writing %i property bytes\n", prop_list->properties_len + prop_list->properties_len_enc_bytes);
+    /* Write total length of properties */
+    PT_MQTT_WRITE_BYTES(conn,
+                        prop_list->properties_len_enc,
+                        prop_list->properties_len_enc_bytes);
+
+    prop = (struct mqtt_prop_out_property *)list_head(prop_list->props);
+    do {
+      if(prop != NULL) {
+        DBG("MQTT - Property ID %i len %i\n", prop->id, prop->property_len);
+        PT_MQTT_WRITE_BYTE(conn, prop->id);
+        PT_MQTT_WRITE_BYTES(conn,
+                            prop->val,
+                            prop->property_len);
+      }
+      prop = (struct mqtt_prop_out_property *)list_item_next(prop);
+    } while(prop != NULL);
+  } else {
+    /* Write Property Length */
+    DBG("MQTT - No properties to write\n");
+    PT_MQTT_WRITE_BYTE(conn, 0);
+  }
+
+  PT_END(pt);
+}
+#endif
+/*---------------------------------------------------------------------------*/
 static
 PT_THREAD(connect_pt(struct pt *pt, struct mqtt_connection *conn))
 {
   PT_BEGIN(pt);
 
+#if MQTT_5
+  static struct mqtt_prop_list *will_props = MQTT_PROP_LIST_NONE;
+  if(conn->will.properties) {
+    will_props = (struct mqtt_prop_list *)list_head(conn->will.properties);
+  }
+#endif
+
   DBG("MQTT - Sending CONNECT message...\n");
 
   /* Set up FHDR */
@@ -433,13 +517,34 @@ PT_THREAD(connect_pt(struct pt *pt, struct mqtt_connection *conn))
   conn->out_packet.remaining_length = 0;
   conn->out_packet.remaining_length += MQTT_CONNECT_VHDR_SIZE;
   conn->out_packet.remaining_length += MQTT_STRING_LENGTH(&conn->client_id);
+#if (MQTT_PROTOCOL_VERSION > MQTT_PROTOCOL_VERSION_3_1) && MQTT_SRV_SUPPORTS_EMPTY_CLIENT_ID
+  /* Ensure we leave space for the 2 length bytes (which will encode 0) */
+  if(MQTT_STRING_LENGTH(&conn->client_id) == 0) {
+    conn->out_packet.remaining_length += 2;
+  }
+#endif
   conn->out_packet.remaining_length += MQTT_STRING_LENGTH(&conn->credentials.username);
   conn->out_packet.remaining_length += MQTT_STRING_LENGTH(&conn->credentials.password);
   conn->out_packet.remaining_length += MQTT_STRING_LENGTH(&conn->will.topic);
   conn->out_packet.remaining_length += MQTT_STRING_LENGTH(&conn->will.message);
-  encode_remaining_length(conn->out_packet.remaining_length_enc,
-                          &conn->out_packet.remaining_length_enc_bytes,
-                          conn->out_packet.remaining_length);
+
+#if MQTT_5
+  /* For connect properties */
+  conn->out_packet.remaining_length +=
+    conn->out_props ? (conn->out_props->properties_len + conn->out_props->properties_len_enc_bytes)
+    : 1;
+
+  /* For will properties */
+  if(conn->connect_vhdr_flags & MQTT_VHDR_WILL_FLAG) {
+    conn->out_packet.remaining_length +=
+      will_props ? will_props->properties_len + will_props->properties_len_enc_bytes
+      : 1;
+  }
+#endif
+
+  mqtt_encode_var_byte_int(conn->out_packet.remaining_length_enc,
+                           &conn->out_packet.remaining_length_enc_bytes,
+                           conn->out_packet.remaining_length);
   if(conn->out_packet.remaining_length_enc_bytes > 4) {
     call_event(conn, MQTT_EVENT_PROTOCOL_ERROR, NULL);
     PRINTF("MQTT - Error, remaining length > 4 bytes\n");
@@ -458,11 +563,24 @@ PT_THREAD(connect_pt(struct pt *pt, struct mqtt_connection *conn))
   PT_MQTT_WRITE_BYTE(conn, conn->connect_vhdr_flags);
   PT_MQTT_WRITE_BYTE(conn, (conn->keep_alive >> 8));
   PT_MQTT_WRITE_BYTE(conn, (conn->keep_alive & 0x00FF));
+
+#if MQTT_5
+  /* Write Properties */
+  write_out_props(pt, conn, conn->out_props);
+#endif
+
+  /* Write Payload */
   PT_MQTT_WRITE_BYTE(conn, conn->client_id.length >> 8);
   PT_MQTT_WRITE_BYTE(conn, conn->client_id.length & 0x00FF);
   PT_MQTT_WRITE_BYTES(conn, (uint8_t *)conn->client_id.string,
                       conn->client_id.length);
+
   if(conn->connect_vhdr_flags & MQTT_VHDR_WILL_FLAG) {
+#if MQTT_5
+    /* Write Will Properties */
+    DBG("MQTT - Writing will properties\n");
+    write_out_props(pt, conn, will_props);
+#endif
     PT_MQTT_WRITE_BYTE(conn, conn->will.topic.length >> 8);
     PT_MQTT_WRITE_BYTE(conn, conn->will.topic.length & 0x00FF);
     PT_MQTT_WRITE_BYTES(conn, (uint8_t *)conn->will.topic.string,
@@ -505,7 +623,11 @@ PT_THREAD(connect_pt(struct pt *pt, struct mqtt_connection *conn))
   if(timer_expired(&conn->t)) {
     DBG("Timeout waiting for CONNACK\n");
     /* We stick to the letter of the spec here: Tear the connection down */
+#if MQTT_5
+    mqtt_disconnect(conn, MQTT_PROP_LIST_NONE);
+#else
     mqtt_disconnect(conn);
+#endif
   }
   reset_packet(&conn->in_packet);
 
@@ -531,6 +653,11 @@ PT_THREAD(disconnect_pt(struct pt *pt, struct mqtt_connection *conn))
   PT_MQTT_WRITE_BYTE(conn, MQTT_FHDR_MSG_TYPE_DISCONNECT);
   PT_MQTT_WRITE_BYTE(conn, 0);
 
+#if MQTT_5
+/* Write Properties */
+  write_out_props(pt, conn, conn->out_props);
+#endif
+
   send_out_buffer(conn);
 
   /*
@@ -561,9 +688,16 @@ PT_THREAD(subscribe_pt(struct pt *pt, struct mqtt_connection *conn))
     MQTT_STRING_LEN_SIZE +
     conn->out_packet.topic_length +
     MQTT_QOS_SIZE;
-  encode_remaining_length(conn->out_packet.remaining_length_enc,
-                          &conn->out_packet.remaining_length_enc_bytes,
-                          conn->out_packet.remaining_length);
+
+#if MQTT_5
+  conn->out_packet.remaining_length +=
+    conn->out_props ? (conn->out_props->properties_len + conn->out_props->properties_len_enc_bytes)
+    : 1;
+#endif
+
+  mqtt_encode_var_byte_int(conn->out_packet.remaining_length_enc,
+                           &conn->out_packet.remaining_length_enc_bytes,
+                           conn->out_packet.remaining_length);
   if(conn->out_packet.remaining_length_enc_bytes > 4) {
     call_event(conn, MQTT_EVENT_PROTOCOL_ERROR, NULL);
     PRINTF("MQTT - Error, remaining length > 4 bytes\n");
@@ -578,12 +712,23 @@ PT_THREAD(subscribe_pt(struct pt *pt, struct mqtt_connection *conn))
   /* Write Variable Header */
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.mid >> 8));
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.mid & 0x00FF));
+
+#if MQTT_5
+  /* Write Properties */
+  write_out_props(pt, conn, conn->out_props);
+#endif
+
   /* Write Payload */
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.topic_length >> 8));
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.topic_length & 0x00FF));
   PT_MQTT_WRITE_BYTES(conn, (uint8_t *)conn->out_packet.topic,
                       conn->out_packet.topic_length);
+
+#if MQTT_5
+  PT_MQTT_WRITE_BYTE(conn, conn->out_packet.sub_options);
+#else
   PT_MQTT_WRITE_BYTE(conn, conn->out_packet.qos);
+#endif
 
   /* Send out buffer */
   send_out_buffer(conn);
@@ -624,9 +769,16 @@ PT_THREAD(unsubscribe_pt(struct pt *pt, struct mqtt_connection *conn))
   conn->out_packet.remaining_length = MQTT_MID_SIZE +
     MQTT_STRING_LEN_SIZE +
     conn->out_packet.topic_length;
-  encode_remaining_length(conn->out_packet.remaining_length_enc,
-                          &conn->out_packet.remaining_length_enc_bytes,
-                          conn->out_packet.remaining_length);
+
+#if MQTT_5
+  conn->out_packet.remaining_length +=
+    conn->out_props ? (conn->out_props->properties_len + conn->out_props->properties_len_enc_bytes)
+    : 1;
+#endif
+
+  mqtt_encode_var_byte_int(conn->out_packet.remaining_length_enc,
+                           &conn->out_packet.remaining_length_enc_bytes,
+                           conn->out_packet.remaining_length);
   if(conn->out_packet.remaining_length_enc_bytes > 4) {
     call_event(conn, MQTT_EVENT_PROTOCOL_ERROR, NULL);
     PRINTF("MQTT - Error, remaining length > 4 bytes\n");
@@ -637,9 +789,15 @@ PT_THREAD(unsubscribe_pt(struct pt *pt, struct mqtt_connection *conn))
   PT_MQTT_WRITE_BYTE(conn, conn->out_packet.fhdr);
   PT_MQTT_WRITE_BYTES(conn, (uint8_t *)conn->out_packet.remaining_length_enc,
                       conn->out_packet.remaining_length_enc_bytes);
+
   /* Write Variable Header */
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.mid >> 8));
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.mid & 0x00FF));
+#if MQTT_5
+  /* Write Properties */
+  write_out_props(pt, conn, conn->out_props);
+#endif
+
   /* Write Payload */
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.topic_length >> 8));
   PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.topic_length & 0x00FF));
@@ -692,9 +850,16 @@ PT_THREAD(publish_pt(struct pt *pt, struct mqtt_connection *conn))
   if(conn->out_packet.qos > MQTT_QOS_LEVEL_0) {
     conn->out_packet.remaining_length += MQTT_MID_SIZE;
   }
-  encode_remaining_length(conn->out_packet.remaining_length_enc,
-                          &conn->out_packet.remaining_length_enc_bytes,
-                          conn->out_packet.remaining_length);
+
+#if MQTT_5
+  conn->out_packet.remaining_length +=
+    conn->out_props ? (conn->out_props->properties_len + conn->out_props->properties_len_enc_bytes)
+    : 1;
+#endif
+
+  mqtt_encode_var_byte_int(conn->out_packet.remaining_length_enc,
+                           &conn->out_packet.remaining_length_enc_bytes,
+                           conn->out_packet.remaining_length);
   if(conn->out_packet.remaining_length_enc_bytes > 4) {
     call_event(conn, MQTT_EVENT_PROTOCOL_ERROR, NULL);
     PRINTF("MQTT - Error, remaining length > 4 bytes\n");
@@ -720,6 +885,11 @@ PT_THREAD(publish_pt(struct pt *pt, struct mqtt_connection *conn))
     PT_MQTT_WRITE_BYTE(conn, (conn->out_packet.mid & 0x00FF));
   }
 
+#if MQTT_5
+  /* Write Properties */
+  write_out_props(pt, conn, conn->out_props);
+#endif
+
   /* Write Payload */
   PT_MQTT_WRITE_BYTES(conn,
                       conn->out_packet.payload,
@@ -792,13 +962,64 @@ PT_THREAD(pingreq_pt(struct pt *pt, struct mqtt_connection *conn))
   PT_END(pt);
 }
 /*---------------------------------------------------------------------------*/
+#if MQTT_5
+static
+PT_THREAD(auth_pt(struct pt *pt, struct mqtt_connection *conn))
+{
+  PT_BEGIN(pt);
+
+  conn->out_packet.remaining_length +=
+    conn->out_props ? (conn->out_props->properties_len + conn->out_props->properties_len_enc_bytes)
+    : 1;
+
+  mqtt_encode_var_byte_int(conn->out_packet.remaining_length_enc,
+                           &conn->out_packet.remaining_length_enc_bytes,
+                           conn->out_packet.remaining_length);
+
+  if(conn->out_packet.remaining_length_enc_bytes > 4) {
+    call_event(conn, MQTT_EVENT_PROTOCOL_ERROR, NULL);
+    PRINTF("MQTT - Error, remaining length > 4 bytes\n");
+    PT_EXIT(pt);
+  }
+
+  /* Write Fixed Header */
+  PT_MQTT_WRITE_BYTE(conn, conn->out_packet.fhdr);
+  PT_MQTT_WRITE_BYTES(conn, (uint8_t *)conn->out_packet.remaining_length_enc,
+                      conn->out_packet.remaining_length_enc_bytes);
+
+  /* Write Variable Header */
+  PT_MQTT_WRITE_BYTE(conn, conn->out_packet.auth_reason_code);
+
+  /* Write Properties */
+  write_out_props(pt, conn, conn->out_props);
+
+  /* No Payload */
+  send_out_buffer(conn);
+
+  PT_WAIT_UNTIL(pt, conn->out_buffer_sent);
+
+  PT_END(pt);
+}
+#endif
+/*---------------------------------------------------------------------------*/
 static void
 handle_connack(struct mqtt_connection *conn)
 {
-  mqtt_connack_event_t connack_event;
+  struct mqtt_connack_event connack_event;
 
   DBG("MQTT - Got CONNACK\n");
 
+#if MQTT_PROTOCOL_VERSION <= MQTT_PROTOCOL_VERSION_3_1_1
+  if(conn->in_packet.remaining_length != 2) {
+    PRINTF("MQTT - CONNACK VHDR remaining length %i incorrect\n",
+           conn->in_packet.remaining_length);
+    call_event(conn,
+               MQTT_EVENT_ERROR,
+               NULL);
+    abort_connection(conn);
+    return;
+  }
+
   if(conn->in_packet.payload[1] != 0) {
     PRINTF("MQTT - Connection refused with Return Code %i\n",
            conn->in_packet.payload[1]);
@@ -808,6 +1029,7 @@ handle_connack(struct mqtt_connection *conn)
     abort_connection(conn);
     return;
   }
+#endif
 
   conn->out_packet.qos_state = MQTT_QOS_STATE_GOT_ACK;
 
@@ -815,6 +1037,24 @@ handle_connack(struct mqtt_connection *conn)
   connack_event.session_present = conn->in_packet.payload[0] & MQTT_VHDR_CONNACK_SESSION_PRESENT;
 #endif
 
+#if MQTT_PROTOCOL_VERSION >= MQTT_PROTOCOL_VERSION_5
+  /* The CONNACK VHDR must contain:
+   * 0: Connect Acknowledge Flags
+   * 1: Connect Reason Code
+   * 2: Properties (whose Length field must be set even if no properties are present)
+   */
+  if(conn->in_packet.remaining_length < 3) {
+    PRINTF("MQTT - CONNACK VHDR remaining length %i incorrect\n",
+           conn->in_packet.remaining_length);
+    call_event(conn,
+               MQTT_EVENT_ERROR,
+               NULL);
+    abort_connection(conn);
+    return;
+  }
+  mqtt_prop_parse_connack_props(conn);
+#endif
+
   ctimer_set(&conn->keep_alive_timer, conn->keep_alive * CLOCK_SECOND,
              keep_alive_callback, conn);
 
@@ -832,45 +1072,49 @@ handle_pingresp(struct mqtt_connection *conn)
 static void
 handle_suback(struct mqtt_connection *conn)
 {
-  mqtt_suback_event_t suback_event;
+  struct mqtt_suback_event suback_event;
 
   DBG("MQTT - Got SUBACK\n");
 
   /* Only accept SUBACKS with X topic QoS response, assume 1 */
+#if MQTT_5
+  if(conn->in_packet.remaining_length > MQTT_MID_SIZE +
+     MQTT_MAX_TOPICS_PER_SUBSCRIBE * MQTT_QOS_SIZE +
+     conn->in_packet.properties_len + conn->in_packet.properties_enc_len) {
+#else
   if(conn->in_packet.remaining_length > MQTT_MID_SIZE +
      MQTT_MAX_TOPICS_PER_SUBSCRIBE * MQTT_QOS_SIZE) {
+#endif
     DBG("MQTT - Error, SUBACK with > 1 topic, not supported.\n");
   }
 
   conn->out_packet.qos_state = MQTT_QOS_STATE_GOT_ACK;
 
-  suback_event.mid = (conn->in_packet.payload[0] << 8) |
-    (conn->in_packet.payload[1]);
-  conn->in_packet.mid = suback_event.mid;
+  suback_event.mid = conn->in_packet.mid;
 
-#if MQTT_311
+#if !MQTT_31
   suback_event.success = 0;
 
-  switch(conn->in_packet.payload[2]) {
+  switch(conn->in_packet.payload_start[0]) {
   case MQTT_SUBACK_RET_FAIL:
-    PRINTF("MQTT - Error, SUBSCRIBE failed with SUBACK return code '%x'", conn->in_packet.payload[2]);
+    PRINTF("MQTT - Error, SUBSCRIBE failed with SUBACK return code '%x'", conn->in_packet.payload_start[0]);
     break;
 
   case MQTT_SUBACK_RET_QOS_0:
   case MQTT_SUBACK_RET_QOS_1:
   case MQTT_SUBACK_RET_QOS_2:
-    suback_event.qos_level = conn->in_packet.payload[2] & 0x03;
+    suback_event.qos_level = conn->in_packet.payload_start[0] & 0x03;
     suback_event.success = 1;
     break;
 
   default:
-    PRINTF("MQTT - Error, Unrecognised SUBACK return code '%x'", conn->in_packet.payload[2]);
+    PRINTF("MQTT - Error, Unrecognised SUBACK return code '%x'", conn->in_packet.payload_start[0]);
     break;
   }
 
-  suback_event.return_code = conn->in_packet.payload[2];
+  suback_event.return_code = conn->in_packet.payload_start[0];
 #else
-  suback_event.qos_level = conn->in_packet.payload[2];
+  suback_event.qos_level = conn->in_packet.payload_start[0];
 #endif
 
   if(conn->in_packet.mid != conn->out_packet.mid) {
@@ -888,8 +1132,6 @@ handle_unsuback(struct mqtt_connection *conn)
   DBG("MQTT - Got UNSUBACK\n");
 
   conn->out_packet.qos_state = MQTT_QOS_STATE_GOT_ACK;
-  conn->in_packet.mid = (conn->in_packet.payload[0] << 8) |
-    (conn->in_packet.payload[1]);
 
   if(conn->in_packet.mid != conn->out_packet.mid) {
     DBG("MQTT - Warning, got UNSUBACK with none matching MID. Currently there is"
@@ -905,8 +1147,6 @@ handle_puback(struct mqtt_connection *conn)
   DBG("MQTT - Got PUBACK\n");
 
   conn->out_packet.qos_state = MQTT_QOS_STATE_GOT_ACK;
-  conn->in_packet.mid = (conn->in_packet.payload[0] << 8) |
-    (conn->in_packet.payload[1]);
 
   call_event(conn, MQTT_EVENT_PUBACK, &conn->in_packet.mid);
 }
@@ -920,14 +1160,18 @@ handle_publish(struct mqtt_connection *conn)
 #if MQTT_PROTOCOL_VERSION >= MQTT_PROTOCOL_VERSION_3_1_1
   if(strlen(conn->in_publish_msg.topic) < conn->in_packet.topic_len) {
     DBG("NULL detected in received PUBLISH topic\n");
+#if MQTT_5
+    mqtt_disconnect(conn, MQTT_PROP_LIST_NONE);
+#else
     mqtt_disconnect(conn);
+#endif
     return MQTT_PUBLISH_ERR;
   }
 #endif
 
-  DBG("MQTT - This chunk is %i bytes\n", conn->in_packet.payload_pos);
+  DBG("MQTT - This chunk is %i bytes\n", conn->in_publish_msg.payload_chunk_length);
 
-  if(((conn->in_packet.fhdr & 0x09) >> 1) > 0) {
+  if(((conn->in_packet.fhdr & 0x09) >> 1) != 0) {
     PRINTF("MQTT - Error, got incoming PUBLISH with QoS > 0, not supported atm!\n");
   }
 
@@ -983,7 +1227,7 @@ parse_publish_vhdr(struct mqtt_connection *conn,
      conn->in_packet.topic_received == 0) {
     copy_bytes = MIN(conn->in_packet.topic_len - conn->in_packet.topic_pos,
                      input_data_len - *pos);
-    DBG("MQTT - topic_pos: %i copy_bytes: %i", conn->in_packet.topic_pos,
+    DBG("MQTT - topic_pos: %i copy_bytes: %i\n", conn->in_packet.topic_pos,
         copy_bytes);
     memcpy(&conn->in_publish_msg.topic[conn->in_packet.topic_pos],
            &input_data_ptr[*pos],
@@ -1006,6 +1250,93 @@ parse_publish_vhdr(struct mqtt_connection *conn,
   }
 }
 /*---------------------------------------------------------------------------*/
+/* MQTTv5 only */
+#if MQTT_5
+static void
+handle_disconnect(struct mqtt_connection *conn)
+{
+  DBG("MQTT - (handle_disconnect) Got DISCONNECT.\n");
+  call_event(conn, MQTT_EVENT_DISCONNECTED, NULL);
+  abort_connection(conn);
+}
+/*---------------------------------------------------------------------------*/
+static void
+handle_auth(struct mqtt_connection *conn)
+{
+  struct mqtt_prop_auth_event event;
+
+  DBG("MQTT - (handle_auth) Got AUTH.\n");
+
+  if((conn->in_packet.fhdr & 0x0F) != 0x0) {
+    call_event(conn,
+               MQTT_EVENT_ERROR,
+               NULL);
+    abort_connection(conn);
+    return;
+  }
+
+  /* AUTH messages from the server */
+  if(conn->state == MQTT_CONN_STATE_CONNECTING_TO_BROKER &&
+     (!conn->in_packet.has_reason_code ||
+      conn->in_packet.reason_code != MQTT_VHDR_RC_CONTINUE_AUTH)) {
+    DBG("MQTT - (handle_auth) Not reauth - Reason Code 0x18 expected!\n");
+  }
+
+  mqtt_prop_parse_auth_props(conn, &event);
+  call_event(conn, MQTT_EVENT_AUTH, &event);
+}
+#endif
+/*---------------------------------------------------------------------------*/
+static void
+parse_vhdr(struct mqtt_connection *conn)
+{
+  conn->in_packet.payload_start = conn->in_packet.payload;
+
+  /* Some message types include a packet identifier */
+  switch(conn->in_packet.fhdr & 0xF0) {
+  case MQTT_FHDR_MSG_TYPE_PUBACK:
+  case MQTT_FHDR_MSG_TYPE_SUBACK:
+  case MQTT_FHDR_MSG_TYPE_UNSUBACK:
+    conn->in_packet.mid = (conn->in_packet.payload[0] << 8) |
+      (conn->in_packet.payload[1]);
+    conn->in_packet.payload_start += 2;
+    break;
+
+  /* Other message types have a 0-length VHDR */
+  /* PUBLISH has a VHDR for QoS > 0, which is currently unsupported */
+  default:
+    break;
+  }
+
+#if MQTT_5
+  /* CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, DISCONNECT and AUTH have a single
+   * Reason Code as part of the Variable Header.
+   * SUBACK and UNSUBACK contain a list of one or more Reason Codes in the Payload.
+   */
+  switch(conn->in_packet.fhdr & 0xF0) {
+  case MQTT_FHDR_MSG_TYPE_CONNACK:
+  case MQTT_FHDR_MSG_TYPE_PUBACK:
+  case MQTT_FHDR_MSG_TYPE_PUBREC:
+  case MQTT_FHDR_MSG_TYPE_PUBREL:
+  case MQTT_FHDR_MSG_TYPE_PUBCOMP:
+  case MQTT_FHDR_MSG_TYPE_DISCONNECT:
+  case MQTT_FHDR_MSG_TYPE_AUTH:
+    conn->in_packet.reason_code = conn->in_packet.payload_start[0];
+    conn->in_packet.has_reason_code = 1;
+    conn->in_packet.payload_start += 1;
+    break;
+
+  default:
+    conn->in_packet.has_reason_code = 0;
+    break;
+  }
+
+  if(!conn->in_packet.has_props) {
+    mqtt_prop_decode_input_props(conn);
+  }
+#endif
+}
+/*---------------------------------------------------------------------------*/
 static int
 tcp_input(struct tcp_socket *s,
           void *ptr,
@@ -1015,8 +1346,8 @@ tcp_input(struct tcp_socket *s,
   struct mqtt_connection *conn = ptr;
   uint32_t pos = 0;
   uint32_t copy_bytes = 0;
-  uint8_t byte;
   mqtt_pub_status_t pub_status;
+  uint8_t remaining_length_bytes;
 
   if(input_data_len == 0) {
     return 0;
@@ -1042,26 +1373,15 @@ tcp_input(struct tcp_socket *s,
 
   /* Read the Remaining Length field, if we do not have it */
   if(!conn->in_packet.has_remaining_length) {
-    do {
-      if(pos >= input_data_len) {
-        return 0;
-      }
-
-      byte = input_data_ptr[pos++];
-      conn->in_packet.byte_counter++;
-      conn->in_packet.remaining_length_bytes++;
-      DBG("MQTT - Read Remaining Length byte\n");
+    remaining_length_bytes =
+      mqtt_decode_var_byte_int(input_data_ptr, input_data_len, &pos,
+                               &conn->in_packet.byte_counter,
+                               &conn->in_packet.remaining_length);
 
-      if(conn->in_packet.byte_counter > 5) {
-        call_event(conn, MQTT_EVENT_ERROR, NULL);
-        DBG("Received more then 4 byte 'remaining lenght'.");
-        return 0;
-      }
-
-      conn->in_packet.remaining_length +=
-        (byte & 127) * conn->in_packet.remaining_multiplier;
-      conn->in_packet.remaining_multiplier *= 128;
-    } while((byte & 128) != 0);
+    if(remaining_length_bytes == 0) {
+      call_event(conn, MQTT_EVENT_ERROR, NULL);
+      return 0;
+    }
 
     DBG("MQTT - Finished reading remaining length byte\n");
     conn->in_packet.has_remaining_length = 1;
@@ -1103,7 +1423,7 @@ tcp_input(struct tcp_socket *s,
     /* Read in as much as we can into the packet payload */
     copy_bytes = MIN(input_data_len - pos,
                      MQTT_INPUT_BUFF_SIZE - conn->in_packet.payload_pos);
-    DBG("- Copied %lu payload bytes\n", copy_bytes);
+    DBG("- Copied %i payload bytes\n", copy_bytes);
     memcpy(&conn->in_packet.payload[conn->in_packet.payload_pos],
            &input_data_ptr[pos],
            copy_bytes);
@@ -1111,12 +1431,14 @@ tcp_input(struct tcp_socket *s,
     conn->in_packet.payload_pos += copy_bytes;
     pos += copy_bytes;
 
-    uint8_t i;
+#if DEBUG_MQTT == 1
+    uint32_t i;
     DBG("MQTT - Copied bytes: \n");
     for(i = 0; i < copy_bytes; i++) {
       DBG("%02X ", conn->in_packet.payload[i]);
     }
     DBG("\n");
+#endif
 
     /* Full buffer, shall only happen to PUBLISH messages. */
     if(MQTT_INPUT_BUFF_SIZE - conn->in_packet.payload_pos == 0) {
@@ -1124,6 +1446,21 @@ tcp_input(struct tcp_socket *s,
       conn->in_publish_msg.payload_chunk_length = MQTT_INPUT_BUFF_SIZE;
       conn->in_publish_msg.payload_left -= MQTT_INPUT_BUFF_SIZE;
 
+#if MQTT_5
+      if(!conn->in_packet.has_props) {
+        mqtt_prop_decode_input_props(conn);
+      }
+
+      if(conn->in_publish_msg.first_chunk) {
+        conn->in_publish_msg.payload_chunk_length -= conn->in_packet.properties_len +
+          conn->in_packet.properties_enc_len;
+
+        /* Payload chunk should point past the MQTT properties and to the payload itself */
+        conn->in_publish_msg.payload_chunk += conn->in_packet.properties_len +
+          conn->in_packet.properties_enc_len;
+      }
+#endif
+
       pub_status = handle_publish(conn);
 
       conn->in_publish_msg.payload_chunk = conn->in_packet.payload;
@@ -1140,6 +1477,8 @@ tcp_input(struct tcp_socket *s,
     }
   }
 
+  parse_vhdr(conn);
+
   /* Debug information */
   DBG("\n");
   /* Take care of input */
@@ -1148,6 +1487,19 @@ tcp_input(struct tcp_socket *s,
   DBG("MQTT - total data was %i bytes of data. \n",
       (MQTT_FHDR_SIZE + conn->in_packet.remaining_length));
 
+#if MQTT_5
+  if(conn->in_packet.has_reason_code &&
+     conn->in_packet.reason_code >= MQTT_VHDR_RC_UNSPEC_ERR) {
+    PRINTF("MQTT - Reason Code indicated error %i\n",
+           conn->in_packet.reason_code);
+    call_event(conn,
+               MQTT_EVENT_ERROR,
+               NULL);
+    abort_connection(conn);
+    return 0;
+  }
+#endif
+
   /* Handle packet here. */
   switch(conn->in_packet.fhdr & 0xF0) {
   case MQTT_FHDR_MSG_TYPE_CONNACK:
@@ -1158,7 +1510,18 @@ tcp_input(struct tcp_socket *s,
     conn->in_publish_msg.payload_chunk = conn->in_packet.payload;
     conn->in_publish_msg.payload_chunk_length = conn->in_packet.payload_pos;
     conn->in_publish_msg.payload_left = 0;
-    (void) handle_publish(conn);
+
+    DBG("MQTT - First chunk? %i\n", conn->in_publish_msg.first_chunk);
+#if MQTT_5
+    if(conn->in_publish_msg.first_chunk) {
+      conn->in_publish_msg.payload_chunk_length -= conn->in_packet.properties_len +
+        conn->in_packet.properties_enc_len;
+      /* Payload chunk should point past the MQTT properties and to the payload itself */
+      conn->in_publish_msg.payload_chunk += conn->in_packet.properties_len +
+        conn->in_packet.properties_enc_len;
+    }
+#endif
+    (void)handle_publish(conn);
     break;
   case MQTT_FHDR_MSG_TYPE_PUBACK:
     handle_puback(conn);
@@ -1182,6 +1545,16 @@ tcp_input(struct tcp_socket *s,
            (conn->in_packet.fhdr & 0xF0));
     break;
 
+#if MQTT_PROTOCOL_VERSION >= MQTT_PROTOCOL_VERSION_5
+  case MQTT_FHDR_MSG_TYPE_DISCONNECT:
+    handle_disconnect(conn);
+    break;
+
+  case MQTT_FHDR_MSG_TYPE_AUTH:
+    handle_auth(conn);
+    break;
+#endif
+
   default:
     /* All server-only message */
     PRINTF("MQTT - Got MQTT Message Type '%i'", (conn->in_packet.fhdr & 0xF0));
@@ -1353,6 +1726,21 @@ PROCESS_THREAD(mqtt_process, ev, data)
         }
       }
     }
+#if MQTT_5
+    if(ev == mqtt_do_auth_event) {
+      conn = data;
+      DBG("MQTT - Got mqtt_do_auth_event!\n");
+
+      if(conn->out_buffer_sent == 1) {
+        PT_INIT(&conn->out_proto_thread);
+        while(auth_pt(&conn->out_proto_thread, conn) < PT_EXITED) {
+          PT_MQTT_WAIT_SEND();
+        }
+      }
+    }
+    /* clear output properties; the next message sent should overwrite them */
+    conn->out_props = NULL;
+#endif
   }
   PROCESS_END();
 }
@@ -1376,8 +1764,10 @@ mqtt_init(void)
     mqtt_event_max = mqtt_abort_now_event;
 
     mqtt_continue_send_event = process_alloc_event();
+    mqtt_do_auth_event = process_alloc_event();
 
     list_init(mqtt_conn_list);
+
     process_start(&mqtt_process, NULL);
     inited = 1;
   }
@@ -1396,14 +1786,20 @@ mqtt_register(struct mqtt_connection *conn, struct process *app_process,
 
   /* Set defaults - Set all to zero to begin with */
   memset(conn, 0, sizeof(struct mqtt_connection));
+#if MQTT_5
+  /* Server capabilities have non-zero defaults */
+  conn->srv_feature_en = -1;
+#endif
   string_to_mqtt_string(&conn->client_id, client_id);
   conn->event_callback = event_callback;
   conn->app_process = app_process;
   conn->auto_reconnect = 1;
   conn->max_segment_size = max_segment_size;
+
   reset_defaults(conn);
 
   mqtt_init();
+
   list_add(mqtt_conn_list, conn);
 
   DBG("MQTT - Registered successfully\n");
@@ -1418,7 +1814,13 @@ mqtt_register(struct mqtt_connection *conn, struct process *app_process,
  */
 mqtt_status_t
 mqtt_connect(struct mqtt_connection *conn, char *host, uint16_t port,
-             uint16_t keep_alive, uint8_t clean_session)
+             uint16_t keep_alive,
+#if MQTT_5
+             uint8_t clean_session,
+             struct mqtt_prop_list *prop_list)
+#else
+             uint8_t clean_session)
+#endif
 {
   uip_ip6addr_t ip6addr;
   uip_ipaddr_t *ipaddr;
@@ -1452,13 +1854,22 @@ mqtt_connect(struct mqtt_connection *conn, char *host, uint16_t port,
    * connection will be initiated when the DNS lookup is finished, in the main
    * event loop.
    */
+#if MQTT_5
+  conn->out_props = prop_list;
+#endif
+
   process_post(&mqtt_process, mqtt_do_connect_tcp_event, conn);
 
   return MQTT_STATUS_OK;
 }
 /*----------------------------------------------------------------------------*/
 void
+#if MQTT_5
+mqtt_disconnect(struct mqtt_connection *conn,
+                struct mqtt_prop_list *prop_list)
+#else
 mqtt_disconnect(struct mqtt_connection *conn)
+#endif
 {
   if(conn->state != MQTT_CONN_STATE_CONNECTED_TO_BROKER) {
     return;
@@ -1466,12 +1877,23 @@ mqtt_disconnect(struct mqtt_connection *conn)
 
   conn->state = MQTT_CONN_STATE_SENDING_MQTT_DISCONNECT;
 
+#if MQTT_5
+  conn->out_props = prop_list;
+#endif
+
   process_post(&mqtt_process, mqtt_do_disconnect_mqtt_event, conn);
 }
 /*----------------------------------------------------------------------------*/
 mqtt_status_t
 mqtt_subscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic,
+#if MQTT_5
+               mqtt_qos_level_t qos_level,
+               mqtt_nl_en_t nl, mqtt_rap_en_t rap,
+               mqtt_retain_handling_t ret_handling,
+               struct mqtt_prop_list *prop_list)
+#else
                mqtt_qos_level_t qos_level)
+#endif
 {
   if(conn->state != MQTT_CONN_STATE_CONNECTED_TO_BROKER) {
     return MQTT_STATUS_NOT_CONNECTED_ERROR;
@@ -1490,15 +1912,38 @@ mqtt_subscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic,
   conn->out_packet.mid = INCREMENT_MID(conn);
   conn->out_packet.topic = topic;
   conn->out_packet.topic_length = strlen(topic);
-  conn->out_packet.qos = qos_level;
   conn->out_packet.qos_state = MQTT_QOS_STATE_NO_ACK;
 
+  if(mid) {
+    *mid = conn->out_packet.mid;
+  }
+
+#if MQTT_5
+  conn->out_packet.sub_options = 0x00;
+  conn->out_packet.sub_options |= qos_level & MQTT_SUB_OPTION_QOS;
+  conn->out_packet.sub_options |= nl & MQTT_SUB_OPTION_NL;
+  conn->out_packet.sub_options |= rap & MQTT_SUB_OPTION_RAP;
+  conn->out_packet.sub_options |= ret_handling & MQTT_SUB_OPTION_RETAIN_HANDLING;
+#else
+  conn->out_packet.qos = qos_level;
+#endif
+
+#if MQTT_5
+  conn->out_props = prop_list;
+#endif
+
   process_post(&mqtt_process, mqtt_do_subscribe_event, conn);
   return MQTT_STATUS_OK;
 }
 /*----------------------------------------------------------------------------*/
 mqtt_status_t
-mqtt_unsubscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic)
+mqtt_unsubscribe(struct mqtt_connection *conn, uint16_t *mid,
+#if MQTT_5
+                 char *topic,
+                 struct mqtt_prop_list *prop_list)
+#else
+                 char *topic)
+#endif
 {
   if(conn->state != MQTT_CONN_STATE_CONNECTED_TO_BROKER) {
     return MQTT_STATUS_NOT_CONNECTED_ERROR;
@@ -1518,6 +1963,14 @@ mqtt_unsubscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic)
   conn->out_packet.topic_length = strlen(topic);
   conn->out_packet.qos_state = MQTT_QOS_STATE_NO_ACK;
 
+  if(mid) {
+    *mid = conn->out_packet.mid;
+  }
+
+#if MQTT_5
+  conn->out_props = prop_list;
+#endif
+
   process_post(&mqtt_process, mqtt_do_unsubscribe_event, conn);
   return MQTT_STATUS_OK;
 }
@@ -1525,7 +1978,14 @@ mqtt_unsubscribe(struct mqtt_connection *conn, uint16_t *mid, char *topic)
 mqtt_status_t
 mqtt_publish(struct mqtt_connection *conn, uint16_t *mid, char *topic,
              uint8_t *payload, uint32_t payload_size,
-             mqtt_qos_level_t qos_level, mqtt_retain_t retain)
+             mqtt_qos_level_t qos_level,
+#if MQTT_5
+             mqtt_retain_t retain,
+             uint8_t topic_alias, mqtt_topic_alias_en_t topic_alias_en,
+             struct mqtt_prop_list *prop_list)
+#else
+             mqtt_retain_t retain)
+#endif
 {
   if(conn->state != MQTT_CONN_STATE_CONNECTED_TO_BROKER) {
     return MQTT_STATUS_NOT_CONNECTED_ERROR;
@@ -1543,13 +2003,36 @@ mqtt_publish(struct mqtt_connection *conn, uint16_t *mid, char *topic,
 
   conn->out_packet.mid = INCREMENT_MID(conn);
   conn->out_packet.retain = retain;
+#if MQTT_5
+  if(topic_alias_en == MQTT_TOPIC_ALIAS_ON) {
+    conn->out_packet.topic = "";
+    conn->out_packet.topic_length = 0;
+    conn->out_packet.topic_alias = topic_alias;
+    if(topic_alias == 0) {
+      DBG("MQTT - Error, a topic alias of 0 is not permitted! It won't be sent.\n");
+    }
+  } else {
+    conn->out_packet.topic = topic;
+    conn->out_packet.topic_length = strlen(topic);
+    conn->out_packet.topic_alias = 0;
+  }
+#else
   conn->out_packet.topic = topic;
   conn->out_packet.topic_length = strlen(topic);
+#endif
   conn->out_packet.payload = payload;
   conn->out_packet.payload_size = payload_size;
   conn->out_packet.qos = qos_level;
   conn->out_packet.qos_state = MQTT_QOS_STATE_NO_ACK;
 
+  if(mid) {
+    *mid = conn->out_packet.mid;
+  }
+
+#if MQTT_5
+  conn->out_props = prop_list;
+#endif
+
   process_post(&mqtt_process, mqtt_do_publish_event, conn);
   return MQTT_STATUS_OK;
 }
@@ -1577,7 +2060,11 @@ mqtt_set_username_password(struct mqtt_connection *conn, char *username,
 /*----------------------------------------------------------------------------*/
 void
 mqtt_set_last_will(struct mqtt_connection *conn, char *topic, char *message,
+#if MQTT_5
+                   mqtt_qos_level_t qos, struct mqtt_prop_list *will_props)
+#else
                    mqtt_qos_level_t qos)
+#endif
 {
   /* Set strings, NULL string will simply set length to zero */
   string_to_mqtt_string(&conn->will.topic, topic);
@@ -1590,6 +2077,36 @@ mqtt_set_last_will(struct mqtt_connection *conn, char *topic, char *message,
     conn->connect_vhdr_flags |= MQTT_VHDR_WILL_FLAG |
       MQTT_VHDR_WILL_RETAIN_FLAG;
   }
+#if MQTT_5
+  conn->will.properties = (list_t)will_props;
+#endif
 }
+/*---------------------------------------------------------------------------*/
+#if MQTT_5
+/*----------------------------------------------------------------------------*/
+/* MQTTv5-specific functions */
+/*----------------------------------------------------------------------------*/
+/*
+ * Send authentication data to broker.
+ *
+ * N.B. Non-blocking call.
+ */
+mqtt_status_t
+mqtt_auth(struct mqtt_connection *conn,
+          mqtt_auth_type_t auth_type,
+          struct mqtt_prop_list *prop_list)
+{
+  DBG("MQTT - Call to mqtt_auth...\n");
+
+  conn->out_packet.fhdr = MQTT_FHDR_MSG_TYPE_AUTH;
+  conn->out_packet.remaining_length = 1; /* for the auth reason code */
+  conn->out_packet.auth_reason_code = MQTT_VHDR_RC_CONTINUE_AUTH + auth_type;
+
+  conn->out_props = prop_list;
+
+  process_post(&mqtt_process, mqtt_do_auth_event, conn);
+  return MQTT_STATUS_OK;
+}
+#endif
 /*----------------------------------------------------------------------------*/
 /** @} */
diff --git a/os/net/app-layer/mqtt/mqtt.h b/os/net/app-layer/mqtt/mqtt.h
index 836f3a4d5..24d5c5580 100644
--- a/os/net/app-layer/mqtt/mqtt.h
+++ b/os/net/app-layer/mqtt/mqtt.h
@@ -148,6 +148,40 @@
 #else
 #define MQTT_SRV_SUPPORTS_EMPTY_CLIENT_ID 0
 #endif
+
+#if MQTT_31
+/* Len MSB(0)
+ * Len LSB(6)
+ * 'M'
+ * 'Q'
+ * 'I'
+ * 's'
+ * 'd'
+ * 'p'
+ * Protocol Level (3)
+ * Connect Flags
+ * Keep Alive MSB
+ * Keep Alive LSB
+ */
+#define MQTT_CONNECT_VHDR_SIZE 12
+#else
+/* Len MSB(0)
+ * Len LSB(4)
+ * 'M'
+ * 'Q'
+ * 'T'
+ * 'T'
+ * Protocol Level (4)
+ * Connect Flags
+ * Keep Alive MSB
+ * Keep Alive LSB
+ */
+#define MQTT_CONNECT_VHDR_SIZE 10
+#endif
+
+#define MQTT_STRING_LEN_SIZE 2
+#define MQTT_MID_SIZE 2
+#define MQTT_QOS_SIZE 1
 /*---------------------------------------------------------------------------*/
 /*
  * Debug configuration, this is similar but not exactly like the Debugging
@@ -165,6 +199,8 @@ extern process_event_t mqtt_update_event;
 
 /* Forward declaration */
 struct mqtt_connection;
+/* Only defined in MQTTv5 */
+struct mqtt_prop_list;
 
 typedef enum {
   MQTT_RETAIN_OFF,
@@ -194,6 +230,8 @@ typedef enum {
   MQTT_EVENT_CONNECTION_REFUSED_ERROR,
   MQTT_EVENT_DNS_ERROR,
   MQTT_EVENT_NOT_IMPLEMENTED_ERROR,
+
+  MQTT_EVENT_AUTH,
   /* Add more */
 } mqtt_event_t;
 
@@ -247,6 +285,97 @@ typedef enum {
   MQTT_CONN_STATE_SENDING_MQTT_DISCONNECT,
 } mqtt_conn_state_t;
 /*---------------------------------------------------------------------------*/
+typedef enum {
+  MQTT_FHDR_MSG_TYPE_CONNECT       = 0x10,
+  MQTT_FHDR_MSG_TYPE_CONNACK       = 0x20,
+  MQTT_FHDR_MSG_TYPE_PUBLISH       = 0x30,
+  MQTT_FHDR_MSG_TYPE_PUBACK        = 0x40,
+  MQTT_FHDR_MSG_TYPE_PUBREC        = 0x50,
+  MQTT_FHDR_MSG_TYPE_PUBREL        = 0x60,
+  MQTT_FHDR_MSG_TYPE_PUBCOMP       = 0x70,
+  MQTT_FHDR_MSG_TYPE_SUBSCRIBE     = 0x80,
+  MQTT_FHDR_MSG_TYPE_SUBACK        = 0x90,
+  MQTT_FHDR_MSG_TYPE_UNSUBSCRIBE   = 0xA0,
+  MQTT_FHDR_MSG_TYPE_UNSUBACK      = 0xB0,
+  MQTT_FHDR_MSG_TYPE_PINGREQ       = 0xC0,
+  MQTT_FHDR_MSG_TYPE_PINGRESP      = 0xD0,
+  MQTT_FHDR_MSG_TYPE_DISCONNECT    = 0xE0,
+  MQTT_FHDR_MSG_TYPE_AUTH          = 0xF0,
+} mqtt_msg_type_t;
+/*---------------------------------------------------------------------------*/
+/* MQTTv5.0 VHDR Properties */
+typedef enum {
+  MQTT_VHDR_PROP_ANY                = 0x00, /* not in standard; for library use */
+  MQTT_VHDR_PROP_PAYLOAD_FMT_IND    = 0x01,
+  MQTT_VHDR_PROP_MSG_EXP_INT        = 0x02,
+  MQTT_VHDR_PROP_CONTENT_TYPE       = 0x03,
+  MQTT_VHDR_PROP_RESP_TOPIC         = 0x08,
+  MQTT_VHDR_PROP_CORRELATION_DATA   = 0x09,
+  MQTT_VHDR_PROP_SUB_ID             = 0x0B,
+  MQTT_VHDR_PROP_SESS_EXP_INT       = 0x11,
+  MQTT_VHDR_PROP_ASSIGNED_CLIENT_ID = 0x12,
+  MQTT_VHDR_PROP_SERVER_KEEP_ALIVE  = 0x13,
+  MQTT_VHDR_PROP_AUTH_METHOD        = 0x15,
+  MQTT_VHDR_PROP_AUTH_DATA          = 0x16,
+  MQTT_VHDR_PROP_REQ_PROBLEM_INFO   = 0x17,
+  MQTT_VHDR_PROP_WILL_DELAY_INT     = 0x18,
+  MQTT_VHDR_PROP_REQ_RESP_INFO      = 0x19,
+  MQTT_VHDR_PROP_RESP_INFO          = 0x1A,
+  MQTT_VHDR_PROP_SERVER_REFERENCE   = 0x1C,
+  MQTT_VHDR_PROP_REASON_STRING      = 0x1F,
+  MQTT_VHDR_PROP_RECEIVE_MAX        = 0x21,
+  MQTT_VHDR_PROP_TOPIC_ALIAS_MAX    = 0x22,
+  MQTT_VHDR_PROP_TOPIC_ALIAS        = 0x23,
+  MQTT_VHDR_PROP_MAX_QOS            = 0x24,
+  MQTT_VHDR_PROP_RETAIN_AVAIL       = 0x25,
+  MQTT_VHDR_PROP_USER_PROP          = 0x26,
+  MQTT_VHDR_PROP_MAX_PKT_SZ         = 0x27,
+  MQTT_VHDR_PROP_WILD_SUB_AVAIL     = 0x28,
+  MQTT_VHDR_PROP_SUB_ID_AVAIL       = 0x29,
+  MQTT_VHDR_PROP_SHARED_SUB_AVAIL   = 0x2A,
+} mqtt_vhdr_prop_t;
+/*---------------------------------------------------------------------------*/
+/* MQTTv5.0 Binary Capabilities */
+typedef enum {
+  MQTT_CAP_RETAIN_AVAIL        = 0x00,
+  MQTT_CAP_WILD_SUB_AVAIL      = 0x01,
+  MQTT_CAP_SUB_ID_AVAIL        = 0x02,
+  MQTT_CAP_SHARED_SUB_AVAIL    = 0x04,
+} mqtt_srv_capability_t;
+
+typedef enum {
+  MQTT_CAP_OFF,
+  MQTT_CAP_ON,
+} mqtt_capability_t;
+
+typedef enum {
+  MQTT_TOPIC_ALIAS_OFF,
+  MQTT_TOPIC_ALIAS_ON,
+} mqtt_topic_alias_en_t;
+
+typedef enum {
+  MQTT_SUB_OPTION_QOS             = 0x03,
+  MQTT_SUB_OPTION_NL              = 0x04,
+  MQTT_SUB_OPTION_RAP             = 0x08,
+  MQTT_SUB_OPTION_RETAIN_HANDLING = 0x30,
+} mqtt_sub_option_t;
+
+typedef enum {
+  MQTT_NL_OFF,
+  MQTT_NL_ON,
+} mqtt_nl_en_t;
+
+typedef enum {
+  MQTT_RAP_OFF,
+  MQTT_RAP_ON,
+} mqtt_rap_en_t;
+
+typedef enum {
+  MQTT_RET_H_SEND_ALL  = 0x00,
+  MQTT_RET_H_SEND_NEW  = 0x01,
+  MQTT_RET_H_SEND_NONE = 0x02,
+} mqtt_retain_handling_t;
+/*---------------------------------------------------------------------------*/
 struct mqtt_string {
   char *string;
   uint16_t length;
@@ -259,18 +388,23 @@ struct mqtt_string {
  *
  * This could be part of a union of event data structures.
  */
-typedef struct {
+struct mqtt_suback_event {
   uint16_t mid;
   mqtt_qos_level_t qos_level;
-#if MQTT_311
+#if !MQTT_31
   uint8_t return_code;
   uint8_t success;
 #endif
-} mqtt_suback_event_t;
+};
 
-typedef struct {
+struct mqtt_connack_event {
   uint8_t session_present;
-} mqtt_connack_event_t;
+};
+
+typedef enum {
+  MQTT_AUTH_NORMAL,
+  MQTT_AUTH_RE_AUTH,
+} mqtt_auth_type_t;
 
 /* This is the MQTT message that is exposed to the end user. */
 struct mqtt_message {
@@ -300,21 +434,34 @@ struct mqtt_in_packet {
   uint16_t mid;
 
   /* Helper variables needed to decode the remaining_length */
-  uint8_t remaining_multiplier;
   uint8_t has_remaining_length;
-  uint8_t remaining_length_bytes;
 
   /* Not the same as payload in the MQTT sense, it also contains the variable
    * header.
    */
-  uint8_t payload_pos;
+  uint16_t payload_pos;
   uint8_t payload[MQTT_INPUT_BUFF_SIZE];
 
+  /* Start of MQTT payload (after VHDR) */
+  uint8_t *payload_start;
+
   /* Message specific data */
   uint16_t topic_len;
   uint16_t topic_pos;
   uint8_t topic_len_received;
   uint8_t topic_received;
+
+  /* Properties */
+#if MQTT_5
+  uint8_t has_reason_code;
+  uint8_t reason_code;
+
+  uint8_t has_props;  /* the properties have been decoded */
+  uint8_t properties_enc_len;  /* number of bytes used to encode property length */
+  uint16_t properties_len; /* length of properties excluding encoded length */
+  uint8_t *props_start;  /* pointer to first byte in first property */
+  uint8_t *curr_props_pos;  /* pointer to property to parse next */
+#endif
 };
 
 /* This struct represents a packet sent to the MQTT server. */
@@ -331,6 +478,12 @@ struct mqtt_out_packet {
   mqtt_qos_level_t qos;
   mqtt_qos_state_t qos_state;
   mqtt_retain_t retain;
+#if MQTT_5
+  uint8_t topic_alias;
+  uint8_t sub_options;
+  /* Continue Auth or Re-auth */
+  uint8_t auth_reason_code;
+#endif
 };
 /*---------------------------------------------------------------------------*/
 /**
@@ -354,6 +507,9 @@ struct mqtt_will {
   struct mqtt_string topic;
   struct mqtt_string message;
   mqtt_qos_level_t qos;
+#if MQTT_5
+  LIST_STRUCT(properties);
+#endif
 };
 
 struct mqtt_credentials {
@@ -407,6 +563,13 @@ struct mqtt_connection {
   uip_ipaddr_t server_ip;
   uint16_t server_port;
   struct tcp_socket socket;
+
+#if MQTT_5
+  /* Server Capabilities */
+  /* Binary capabilities (default: enabled) */
+  uint8_t srv_feature_en;
+  struct mqtt_prop_list *out_props;
+#endif
 };
 /* This is the API exposed to the user. */
 /*---------------------------------------------------------------------------*/
@@ -441,6 +604,7 @@ mqtt_status_t mqtt_register(struct mqtt_connection *conn,
  *        from the client. Shall be min 1.5 x report interval.
  * \param clean_session Request a new session and discard pending messages with
  *        QoS > 0, as well as client subscriptions
+ * \param prop_list Output properties (MQTTv5-only).
  * \return MQTT_STATUS_OK or an error status
  *
  * This function connects to a MQTT broker.
@@ -449,15 +613,26 @@ mqtt_status_t mqtt_connect(struct mqtt_connection *conn,
                            char *host,
                            uint16_t port,
                            uint16_t keep_alive,
+#if MQTT_5
+                           uint8_t clean_session,
+                           struct mqtt_prop_list *prop_list);
+#else
                            uint8_t clean_session);
+#endif
 /*---------------------------------------------------------------------------*/
 /**
  * \brief Disconnects from a MQTT broker.
  * \param conn A pointer to the MQTT connection.
+ * \param prop_list Output properties (MQTTv5-only).
  *
  * This function disconnects from a MQTT broker.
  */
+#if MQTT_5
+void mqtt_disconnect(struct mqtt_connection *conn,
+                     struct mqtt_prop_list *prop_list);
+#else
 void mqtt_disconnect(struct mqtt_connection *conn);
+#endif
 /*---------------------------------------------------------------------------*/
 /**
  * \brief Subscribes to a MQTT topic.
@@ -465,6 +640,10 @@ void mqtt_disconnect(struct mqtt_connection *conn);
  * \param mid A pointer to message ID.
  * \param topic A pointer to the topic to subscribe to.
  * \param qos_level Quality Of Service level to use. Currently supports 0, 1.
+ * \param nl No Local (MQTTv5-only).
+ * \param rap Retain As Published (MQTTv5-only).
+ * \param ret_handling Retain handling options (MQTTv5-only).
+ * \param prop_list Output properties (MQTTv5-only).
  * \return MQTT_STATUS_OK or some error status
  *
  * This function subscribes to a topic on a MQTT broker.
@@ -472,20 +651,33 @@ void mqtt_disconnect(struct mqtt_connection *conn);
 mqtt_status_t mqtt_subscribe(struct mqtt_connection *conn,
                              uint16_t *mid,
                              char *topic,
+#if MQTT_5
+                             mqtt_qos_level_t qos_level,
+                             mqtt_nl_en_t nl, mqtt_rap_en_t rap,
+                             mqtt_retain_handling_t ret_handling,
+                             struct mqtt_prop_list *prop_list);
+#else
                              mqtt_qos_level_t qos_level);
+#endif
 /*---------------------------------------------------------------------------*/
 /**
  * \brief Unsubscribes from a MQTT topic.
  * \param conn A pointer to the MQTT connection.
  * \param mid A pointer to message ID.
  * \param topic A pointer to the topic to unsubscribe from.
+ * \param prop_list Output properties (MQTTv5-only).
  * \return MQTT_STATUS_OK or some error status
  *
  * This function unsubscribes from a topic on a MQTT broker.
  */
 mqtt_status_t mqtt_unsubscribe(struct mqtt_connection *conn,
                                uint16_t *mid,
+#if MQTT_5
+                               char *topic,
+                               struct mqtt_prop_list *prop_list);
+#else
                                char *topic);
+#endif
 /*---------------------------------------------------------------------------*/
 /**
  * \brief Publish to a MQTT topic.
@@ -499,6 +691,10 @@ mqtt_status_t mqtt_unsubscribe(struct mqtt_connection *conn,
  *        Client to a Server, the Server MUST store the Application Message
  *        and its QoS, so that it can be delivered to future subscribers whose
  *        subscriptions match its topic name
+ * \param topic_alias Topic alias to send (MQTTv5-only).
+ * \param topic_alias_en Control whether or not to discard topic and only send
+ *        topic alias s(MQTTv5-only).
+ * \param prop_list Output properties (MQTTv5-only).
  * \return MQTT_STATUS_OK or some error status
  *
  * This function publishes to a topic on a MQTT broker.
@@ -509,7 +705,14 @@ mqtt_status_t mqtt_publish(struct mqtt_connection *conn,
                            uint8_t *payload,
                            uint32_t payload_size,
                            mqtt_qos_level_t qos_level,
+#if MQTT_5
+                           mqtt_retain_t retain,
+                           uint8_t topic_alias,
+                           mqtt_topic_alias_en_t topic_alias_en,
+                           struct mqtt_prop_list *prop_list);
+#else
                            mqtt_retain_t retain);
+#endif
 /*---------------------------------------------------------------------------*/
 /**
  * \brief Set the user name and password for a MQTT client.
@@ -530,6 +733,7 @@ void mqtt_set_username_password(struct mqtt_connection *conn,
  * \param topic A pointer to the Last Will topic.
  * \param message A pointer to the Last Will message (payload).
  * \param qos The desired QoS level.
+ * \param will_props Will message properties (MQTTv5-only).
  *
  * This function sets clients Last Will topic and message (payload).
  * If the Will Flag is set to 1 (using the function) this indicates that,
@@ -544,7 +748,12 @@ void mqtt_set_username_password(struct mqtt_connection *conn,
 void mqtt_set_last_will(struct mqtt_connection *conn,
                         char *topic,
                         char *message,
+#if MQTT_5
+                        mqtt_qos_level_t qos,
+                        struct mqtt_prop_list *will_props);
+#else
                         mqtt_qos_level_t qos);
+#endif
 
 #define mqtt_connected(conn) \
   ((conn)->state == MQTT_CONN_STATE_CONNECTED_TO_BROKER ? 1 : 0)
@@ -552,6 +761,30 @@ void mqtt_set_last_will(struct mqtt_connection *conn,
 #define mqtt_ready(conn) \
   (!(conn)->out_queue_full && mqtt_connected((conn)))
 /*---------------------------------------------------------------------------*/
+void mqtt_encode_var_byte_int(uint8_t *vbi_out,
+                              uint8_t *vbi_bytes,
+                              uint32_t val);
+/*---------------------------------------------------------------------------*/
+uint8_t mqtt_decode_var_byte_int(const uint8_t *input_data_ptr,
+                                 int input_data_len,
+                                 uint32_t *input_pos,
+                                 uint32_t *pkt_byte_count,
+                                 uint16_t *dest);
+/*---------------------------------------------------------------------------*/
+/**
+ * \brief Send authentication message (MQTTv5-only).
+ * \param conn A pointer to the MQTT connection.
+ * \param auth_type The type of auth to send (continue authentication or
+ *        re-authentication).
+ * \param prop_list Output properties.
+ * \return MQTT_STATUS_OK or some error status
+ *
+ * This function send an MQTT authentication message.
+ */
+mqtt_status_t mqtt_auth(struct mqtt_connection *conn,
+                        mqtt_auth_type_t auth_type,
+                        struct mqtt_prop_list *prop_list);
+/*---------------------------------------------------------------------------*/
 #endif /* MQTT_H_ */
 /*---------------------------------------------------------------------------*/
 /**
-- 
2.45.2

