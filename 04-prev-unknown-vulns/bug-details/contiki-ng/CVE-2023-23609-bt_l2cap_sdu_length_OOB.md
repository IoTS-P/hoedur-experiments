# Buffer Overflow in `input_l2cap_frame_flow_channel`

## Summary

Improper size validation of the incoming radio frames can lead to an out-of-bounds write to `packetbuf`.

## Proposed Advisory Text

The BLE-L2CAP (Bluetooth Low Energy - Logical Link Control and Adaptation Layer Protocol) implemenation handles fragmentation up the configured MTU size, after processing the data is stored `packetbuf`.

However, there is no check to verify `packetbuf` can hold a fully reassembled packet. It is therefore possible in the default configuration that an out-of-bounds write of up to 1152 bytes occurs. This can lead to a denial of service or possibly a remote code execution.

## Description

Incoming fragmented in [`input_l2cap_frame_flow_channel`](https://github.com/contiki-ng/contiki-ng/blob/d544f2ec1e0b9bf37229fe8e8ac846f794efa70d/os/net/mac/ble/ble-l2cap.c#L411) can be up to 1280 bytes (`BLE_L2CAP_NODE_MTU`) while the target buffer `packetbuf` is only 128. (Defaults)

```c
#define BLE_L2CAP_NODE_MTU              1280
```

https://github.com/contiki-ng/contiki-ng/blob/d544f2ec1e0b9bf37229fe8e8ac846f794efa70d/os/net/mac/ble/ble-l2cap.h#L72-L77

```c
#define PACKETBUF_SIZE 128
```

https://github.com/contiki-ng/contiki-ng/blob/d544f2ec1e0b9bf37229fe8e8ac846f794efa70d/os/net/packetbuf.h#L61-L68



When all fragments are received the data is unconditionally copied to the `packetbuf` which leads to an attacker controlled out-of-bounds write of up to 1152 bytes.

```c
memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);
```

https://github.com/contiki-ng/contiki-ng/blob/d544f2ec1e0b9bf37229fe8e8ac846f794efa70d/os/net/mac/ble/ble-l2cap.c#L411

## Impact

- The attack can likely get remote code execution due to control over content and length of the out-of-bounds write.
- Denial of service (large OOB-write)

## Proposed Fix

see `proposed-fixes/0001-verify-packetbuf-is-large-enough-for-frames.patch`
