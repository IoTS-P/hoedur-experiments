# Out of Bounds write in routing with SRH

## Summary
`gnrc_rpl_srh_process` does no bounds checking on the number of addresses supplied in the header.

## Description
If RPL with SRH is used the next hop is read from an array of addresses.
The next address to use is calculated based one `current_pos` without any bounds checks [source](https://github.com/RIOT-OS/RIOT/blob/ccbb304eae7b59e8aca24a6ffd095b5b3f7720ee/sys/net/gnrc/routing/rpl/srh/gnrc_rpl_srh.c#L98):
```
    current_address = &addr_vec[(current_pos - 1) * compri_addr_len];
    memcpy(&addr.u8[pref_elided], current_address, addr_len);
```
The out of bounds access manifests as follows:
1. Calculate `current_address` which is out of bounds from `addr_vec`
2. `memcpy` from `current_address` to `addr`
3. Some checks are preformed with `addr`
4. `memcpy` from `addr` to `current_address`

During step 3 a interrupt can occur an change the content of `current_address`.
Then step 4 overwrites `current_address` again destroying the new contents.
This can lead to corrupted pointers, resulting in a crash.

## Impact
* A crafted packet can lead to corrupted pointers in the packet buffer
* Corrupting a pointer will easily lead to DoS
* Carefully manipulating the allocator metadata gives an attacker the possibility to write data to arbitrary locations and potentially escalate to RCE
