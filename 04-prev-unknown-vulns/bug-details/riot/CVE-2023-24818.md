# NULL pointer dereference during fragment forwarding

## Summary
A IEEE 802.15.4 packet without source address leads to the use of an uninitialized vrb entry resulting in a NULL pointer dereference.

## Description

### Missing source address leads to NULL pointer dereference
NULL pointer dereference in `gnrc_sixlowpan_dispatch_send` due to unchecked use of return value from `gnrc_netif_get_by_pid` [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/network_layer/sixlowpan/gnrc_sixlowpan.c#L98):
```
void gnrc_sixlowpan_dispatch_send(gnrc_pktsnip_t *pkt, void *context,
                                  unsigned page)
{
    (void)context;
    (void)page;
    assert(pkt->type == GNRC_NETTYPE_NETIF);
    gnrc_netif_hdr_t *hdr = pkt->data;
    if (gnrc_netif_send(gnrc_netif_get_by_pid(hdr->if_pid), pkt) < 1) {
```
The return value is NULL because `hdr->if_pid` is zero, which is defined as invalid pid.
The function is called in `gnrc_sixlowpan_frag_minfwd_forward`, where the netif header is build from the `vrbe` [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/network_layer/sixlowpan/frag/minfwd/gnrc_sixlowpan_frag_minfwd.c#L69):
```
    tmp = _netif_hdr_from_vrbe(vrbe);
    ...
    pkt = gnrc_pkt_prepend(pkt, tmp);
    gnrc_sixlowpan_dispatch_send(pkt, NULL, page);
```
The function is called from `_forward_frag`, which just passes the `vrbe` through, which is then called from `_rbuf_add`.
There the `vrb` is retrieved via `gnrc_sixlowpan_frag_vrb_get` [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/network_layer/sixlowpan/frag/rb/gnrc_sixlowpan_frag_rb.c#L336):
```
    (entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,
                                             datagram_tag)) != NULL) {
    ...
    if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,
                  page) < 0) {
```
The problem here is that the `netif_hdr->src_l2addr_len` is zero and an empty vrb entry is defined as having `super.src_len == 0`.
This leads to the situation that `gnrc_sixlowpan_frag_vrb_get` returns an uninitialized vrb entry.

The same bug can be triggered via another path: `gnrc_sixlowpan_frag_sfr_recv` -> `_forward_rfrag` -> `_send_frame`

### Cause of missing address in netif header
The `netif_hdr` is created by the link layer, in this case the IEEE 802.15.4 netif layer.
In `_recv` the function `_make_netif_hdr` is called to set the values in the header [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/netif/ieee802154/gnrc_netif_ieee802154.c#L153):
```
    netif_hdr = _make_netif_hdr(mhr);
```
Here the source and destination addresses are retrieved and written to the `netif_hdr` [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/netif/ieee802154/gnrc_netif_ieee802154.c#L55):
```
    dst_len = ieee802154_get_dst(mhr, dst, &_pan_tmp);
    src_len = ieee802154_get_src(mhr, src, &_pan_tmp);
        if ((dst_len < 0) || (src_len < 0)) {
        DEBUG("_make_netif_hdr: unable to get addresses\n");
        return NULL;
    }
    /* allocate space for header */
    snip = gnrc_netif_hdr_build(src, (size_t)src_len, dst, (size_t)dst_len);
```
These functions decode the Frame Type header and if the Destination/Source Addressing Mode specifies that the address is not present a length of zero is returned.
Thus the addresses are absent from the packet forwarded to the 6LoWPAN layer.

## Impact
* If fragment forwarding is enabled, a crafted packet can trigger a null pointer dereference, leading to DoS

## Potential fix

### Missing address in netif header
IEEE 802.15.4 states in section 5.2.1.1.6 for the Destination Addressing Mode field:
> If this field is equal to zero and the Frame Type field does not specify that this frame is an acknowledgment
> or beacon frame, the Source Addressing Mode field shall be nonzero, implying that the frame is directed to
> the PAN coordinator with the PAN identifier as specified in the Source PAN Identifier field.

And the Source Addressing Mode is defined in a similar way:
> If this field is equal to zero and the Frame Type field does not specify that this frame is an acknowledgment
> frame, the Destination Addressing Mode field shall be nonzero, implying that the frame has originated from
> the PAN coordinator with the PAN identifier as specified in the Destination PAN Identifier field.

Either of the Destination or Source Address must be present and the other address is taken from the PAN Identifier.
Change the `ieee802154_get_*` functions to return an error if neither field exists.
Similar functionality is already implemented for `ieee802154_set_frame_hdr`.
A patch for `ieee802154_get_frame_hdr_len` is attached but it might be necessary to implement more verification in `ieee802154_get_src` and `ieee802154_get_dst`.

It seems that the handling of PAN IDs is currently not implemented.
So one fix would be to ignore all packets without a source address.

### Additional debug checks
Additional asserts can be added to the functions that assume a source address exists.
If the netif header should always contain a source address it might be better to implement a runtime check in the netif layer.

