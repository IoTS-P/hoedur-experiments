# Packet Type Confusion during IPHC send

## Summary
During IPHC encoding of the IPv6 header for 6LoWPAN, wrong assumptions of the snippet type can lead to an OOB write in the packet buffer.
The snippet type `GNRC_NETTYPE_UNDEF` is wrongly assumed to be UDP but can instead contain IPv6 extension headers.
Only space for a UDP header is allocated in the IPHC snippet but the headers would require a much larger snippet.


## Description

### Reflecting packets
Every received packet is first decoded by the 6LoWPAN layer.
All remaining data is appended to the IPv6 snippet even if it is not part of the header.
The IPv6 layer extracts only the header into a new snippet and marks the remaining data, including extension headers, as `GNRC_NETTYPE_UNDEF`.
If the packet is not for the device and is not send via a link local address it is forwarded and thus send back to the network without processing the extension headers.
On the way back the 6LoWPAN layer compresses the IPv6 header again.

### Packet type assumptions
During calculation of the size for the IPHC snippet the first snippet of type `GNRC_NETTYPE_UNDEF` is assumed to be the UDP header and only the required 8 bytes are added to the size.
But during forwarding this snippet can also contain the IPv6 extension headers which may be much larger [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1593)
```
if (ptr->type == GNRC_NETTYPE_UNDEF) {
    /* most likely UDP for now so use that (XXX: extend if extension
     * headers make problems) */
    dispatch_size += sizeof(udp_hdr_t);
    break;  /* nothing special after UDP so quit even if more UNDEF
             * come */
}
else {
    dispatch_size += ptr->size;
}
...
dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,
                           GNRC_NETTYPE_SIXLOWPAN);
```
While compressing the headers the type is only taken from the next header field of the IPv6 header/extension header and not from the snippet type [source](https://github.com/RIOT-OS/RIOT/blob/2022.07-branch/sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c#L1626):
```
    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;
#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC
    while (_compressible_nh(nh)) {
        ssize_t local_pos = 0;
        switch (nh) {
            case PROTNUM_UDP:
                ...
            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */
                ...
            case PROTNUM_IPV6_EXT_HOPOPT:
            case PROTNUM_IPV6_EXT_RH:
            case PROTNUM_IPV6_EXT_FRAG:
            case PROTNUM_IPV6_EXT_DST:
            case PROTNUM_IPV6_EXT_MOB:
                ...
```
The compressed headers can be larger than the allocated space and thus overflow the allocated packet buffer.

## Impact
* An attacker can manipulate data on the packet buffer and thus corrupt other packets and the allocator metadata
* Corrupting a pointer will easily lead to DoS
* Carefully manipulating the allocator metadata gives an attacker the possibility to write data to arbitrary locations and potentially escalate to RCE

## Potential fix
Remove the special handling for `GNRC_NETTYPE_UNDEF` and allocate the entire size for each snippet.
As the headers can only be reduced in size during compression the overflow will be removed.
After compressing all headers the snippet is truncated to the required size thus the resulting packet will not be larger then necessary.

