# sent_cmd Shared Reference Race Condition
Disclaimer: Our finding of this issue has been reproduced in our fuzzer on a target built from commit `e1dddf7befa7309bd2afc567b2e00d2e7362f7c4`. The original target was [CVE-2021-3329](https://github.com/fuzzware-fuzzer/fuzzware-experiments/tree/main/03-fuzzing-new-targets/zephyr-os/prebuilt_samples/CVE-2021-3329) (which can be built via [this script](https://github.com/fuzzware-fuzzer/fuzzware-experiments/blob/main/03-fuzzing-new-targets/zephyr-os/building/build_sample_CVE-2021-3329.sh)). Based on reviewing the source code, we concluded that the race condition still applies as of the latest commit at time of writing (commit `e458f5aae63bbdd0a8310da450a8ad8eac700758`).

## Summary

A race condition on the use of shared references on the bluetooth h4 HCI packet output buffer handling in the bluetooth host layer may lead to a use-after-free condition. This condition may allow a malfunctioning/malicious HCI controller to hijack control flow of the bluetooth host layer.

## Description

To handle bluetooth communications in the h4 host layer, different components are involved:

1. interrupt handler bt_uart_isr:
    - receive: Accepts low-level HCI packets from UART peripheral and pushes them to `rx.fifo` via `process_rx`
    - transmit: Accepts HCI packets from tx_thread via `tx.fifo` and transfers them to controller
2. rx_thread: Thread which processes incoming HCI packets from `rx.fifo` and (optionally) triggers sending new command packets via appending to `bt_dev.cmd_tx_queue` (via `bt_hci_cmd_send`)
3. tx_thread:
    - Thread which retrieves packets from `bt_dev.cmd_tx_queue` and sends them to interrupt handler via appending to `tx.fifo`
    - Importantly, while appending to `tx.fifo`, tx_thread also sets the global `bt_dev.sent_cmd` to the latest sent command

The global variable `bt_dev.sent_cmd` is used to keep track of the latest command that was sent to be able to match incoming completion status events to previously sent HCI packets.

The code seems to make the assumption that the following sequence holds:
1. Packet from `tx.fifo` is sent to controller
2. Controller acknowledges the packet (which matches the last command stored in `bt_dev.sent_cmd`)

Due to this assumption the following optimization is done during packet receive: In case a completion status event is received, the buffer stored within `bt_dev.sent_cmd` is re-used immediately for the incoming packet data.
This optimized allocation is triggered in the following call chain: `bt_uart_isr` -> `process_rx` -> `read_payload` -> `get_rx` -> `bt_buf_get_evt` -> `bt_buf_get_cmd_complete`.
Link: https://github.com/zephyrproject-rtos/zephyr/blob/e458f5aae63bbdd0a8310da450a8ad8eac700758/subsys/bluetooth/host/buf.c#L92-L99

However, the assumption that the buffer referenced by `bt_dev.sent_cmd` can be re-used does not hold in all cases. This is due to a race condition. Consider the following sequence of events:
1. tx_thread sends a packet, thus retrieves it from `bt_dev.cmd_tx_queue` and
    - appends the packet buffer to `tx.fifo`
    - increments the buffer's reference count and assigns its reference to `bt_dev.sent_cmd`
2. UART interrupt occurs (`bt_uart_isr` is executed).
    - the packet is not immediately removed from `tx.fifo`, e.g. as UART tx is not ready (resulting in `process_tx` not being called)
    - interrupt handler processes incoming HCI packet via `process_rx`
        - the incoming HCI packet is a completion status event (which indicates an acknowledgement)
        - `process_rx`->`read_payload` requests a buffer via `get_rx` [source code link](https://github.com/zephyrproject-rtos/zephyr/blob/cd26df75b50737435e8e7bd019ddd3d5c8240fdb/drivers/bluetooth/hci/h4.c#L287)
            - the buffer request triggers the optimized buffer re-use of `bt_dev.sent_cmd` (see above)
        - to enable further processing, the interrupt handler appends the buffer to `rx.fifo` ([source code link](https://github.com/zephyrproject-rtos/zephyr/blob/cd26df75b50737435e8e7bd019ddd3d5c8240fdb/drivers/bluetooth/hci/h4.c#L351))
3. Right now, the pointer to the packet buffer is present in BOTH `tx.fifo` (as it has not been sent) and `rx.fifo`

This situation contains different types of invalid state:
1. The contents of the outgoing packet are overwritten by the incoming data
2. As a pointer is present in both queues, operations on the `rx`/`tx` queues become invalid, leading to a potential double free / dangling reference. Consider
    - Base state
        - `tx.fifo` containing only buffer `x`
        - `rx.fifo` containing only buffer `x`
        - Buffer `x` (currently correctly) has reference count 2
    - Operation on `tx.fifo` causing an invalid state
        - An additional packet `y` is received
        - `y` is appended to `rx.fifo` (via `net_buf_put`)
        - Result: `rx.fifo` has been updated to `x` -> `y`
            - Side effect: `tx.fifo` now also is `x` -> `y`
            - `y` has a reference count of 1, but is present in both queues
        - `rx_thread` processes its next packet: `rx_thread` pops from the front of the queue `rx.fifo` via `net_buf_get`: [link](https://github.com/zephyrproject-rtos/zephyr/blob/cd26df75b50737435e8e7bd019ddd3d5c8240fdb/drivers/bluetooth/hci/h4.c#L259)
        - Result: `x` has been removed from `rx.fifo`, which now only contains `y`
            - Note that `tx.fifo` still contains `x` -> `y`
        - `rx_thread` processes a second packet
        - Result: `y` has been removed from `rx.fifo`, which is now empty
            - `y` refcount is decremented to 0 and freed (put back into its pool)
            - However: `tx.fifo` still contains `x` -> `y`
            - Dangling reference: This means that an additional reference to `y` is held within `tx.fifo`
        - `tx.fifo` is emptied by `bt_uart_isr` and the now free `y` is operated on

This invalid state leads to different crashing effects.

## Impact

A malicious / malfunctioning HCI Controller may cause a Use-after-free resulting in potential Remote Code Execution (RCE) on the Bluetooth host layer.

## Proposed Fix

To avoid this issue, the code should ensure that `bt_dev.sent_cmd` will not be re-used for input processing until the underlying buffer has actually been removed from `tx.fifo` and has been sent. Removing the optimized allocation altogether would achieve this goal, but there may be ways to keep the performance boost while avoiding this race.
