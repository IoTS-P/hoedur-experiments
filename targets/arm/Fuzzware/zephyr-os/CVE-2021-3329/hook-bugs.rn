struct MtuSetup { hit }
struct LeInit { invalid_init }
struct IsrState { depth }
struct SentCmdState { bug, is_buf_handed_out_when_in_tx_fifo }
struct SemaState { valid, head, tail }
struct CmdData { state, state_target }
struct ArchSwap { bug, pendsv }

pub fn main(api) {
    // CVE check
    let semaphores = [];
    let mtu_setup = MtuSetup { hit: false };
    api.on_prepare_run(|| { semaphores.clear(); semaphores.push(0x20002f98); mtu_setup.hit = false; });
    api.on_basic_block(Some(symbolizer::resolve("z_impl_k_sem_init")?), |_| on_semaphore_init(semaphores));
    api.on_basic_block(Some(symbolizer::resolve("bt_init")?+0x1e0), |_| on_bt_init(mtu_setup));
    api.on_basic_block(Some(symbolizer::resolve("send_frag")?), |_| on_CVE_2021_3329(semaphores, mtu_setup));
    api.on_basic_block(Some(symbolizer::resolve("z_impl_k_sem_take")?), |_| on_z_impl_k_sem_take(semaphores));
    api.on_basic_block(Some(symbolizer::resolve("z_clock_announce")?+0x84), |_| on_timeout_callback());
    api.on_basic_block(Some(symbolizer::resolve("tx_free")?), |_| on_tx_free());
    api.on_basic_block(Some(symbolizer::resolve("net_buf_simple_push")?), |_| on_net_buf_simple_push());
    api.on_basic_block(Some(symbolizer::resolve("z_add_timeout")?), |_| on_z_add_timeout());
    api.on_basic_block(Some(symbolizer::resolve("k_delayed_work_init")?), |_| on_k_delayed_work_init());

    // PORTING: The basic block we are hooking here is in heavily inlined parts within bt_init -> hci_init -> le_init -> le_read_buffer_size_complete
    // Specifically, we target the "bt_hci_cmd_send_sync(0x2002u, ...)", which is "bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE, ...)"
    // location 1:
    // https://github.com/zephyrproject-rtos/zephyr/blob/e1dddf7befa7309bd2afc567b2e00d2e7362f7c4/subsys/bluetooth/host/hci_core.c#L5576
    // https://github.com/zephyrproject-rtos/zephyr/blob/e1dddf7befa7309bd2afc567b2e00d2e7362f7c4/subsys/bluetooth/host/hci_core.c#L5350-L5357
    // location 2:
    // https://github.com/zephyrproject-rtos/zephyr/blob/e1dddf7befa7309bd2afc567b2e00d2e7362f7c4/subsys/bluetooth/host/hci_core.c#L5784
    // https://github.com/zephyrproject-rtos/zephyr/blob/e1dddf7befa7309bd2afc567b2e00d2e7362f7c4/subsys/bluetooth/host/hci_core.c#L5334-L5339
    let le_init = LeInit { invalid_init: false };
    api.on_prepare_run(|| { le_init.invalid_init = false; });
    api.on_basic_block(Some(symbolizer::resolve("bt_init")?+0x1ba), |_| on_le_init_check_1(le_init));
    api.on_basic_block(Some(symbolizer::resolve("bt_init")?+0x2ae), |_| on_le_init_check_2(le_init));
    api.on_basic_block(Some(symbolizer::resolve("z_impl_k_sem_take")?), |_| on_le_init_sem_take(le_init));

    // Bug: new-Bug-hci_prio_event_alloc_err_handling
    let isr_state = IsrState { depth: 0 };
    // PORTING: Ensure that upon start of a new run we are not within an ISR (depth = 0)
    api.on_prepare_run(|| { isr_state.depth = 0; });
    api.on_basic_block(Some(symbolizer::resolve("_isr_wrapper")?), |_| on_isr_entry(isr_state));
    api.on_basic_block(Some(symbolizer::resolve("z_arm_int_exit")?), |_| on_isr_exit(isr_state));
    // PORTING: Make sure that the return of net_buf_alloc_len is at the specified offset
    api.on_basic_block(Some(symbolizer::resolve("net_buf_alloc_len")? + 0xe6), |_| on_net_buf_alloc_len_ret_check_nullptr_in_isr(isr_state));

    // Bug: new-Bug-sent_cmd_shared_ref_race
    // PORTING: Make sure that the sent_cmd re-use case of bt_buf_get_cmd_complete is at the correct offset
    let sent_cmd_state = SentCmdState { bug: false, is_buf_handed_out_when_in_tx_fifo: false };
    api.on_prepare_run(|| { sent_cmd_state.bug = false; sent_cmd_state.is_buf_handed_out_when_in_tx_fifo = false; });
    api.on_basic_block(Some(symbolizer::resolve("bt_buf_get_cmd_complete")? + 0x36), |_| on_bt_buf_get_cmd_complete_sent_cmd_reuse(sent_cmd_state));
    api.on_basic_block(Some(symbolizer::resolve("net_buf_put")?), |_| on_net_buf_put_check_rx_tx_fifo_state(sent_cmd_state));

    // Bug: new-Bug-hci-send_sync-dangling-sema-ref
    let send_sync_sema_states = [SemaState { valid: false, head: 0, tail: 0}, SemaState { valid: false, head: 0, tail: 0}];
    api.on_prepare_run(|| { send_sync_sema_states[0].valid = false; send_sync_sema_states[1].valid = false; });
    // PORTING: Offset: return from first call to net_buf_id within bt_hci_cmd_send_sync (pre z_impl_k_sem_take on sync_sem)
    api.on_basic_block(Some(symbolizer::resolve("bt_hci_cmd_send_sync")? + 0x24), |_| on_bt_hci_cmd_send_sync_set_valid(send_sync_sema_states));
    // PORTING: Offset: return from second call to net_buf_id within bt_hci_cmd_send_sync (post z_impl_k_sem_take on sync_sem)
    api.on_basic_block(Some(symbolizer::resolve("bt_hci_cmd_send_sync")? + 0x78), |_| on_bt_hci_cmd_send_sync_set_invalid(send_sync_sema_states));
    // PORTING: Offset: return from last net_buf_id call in hci_cmd_done before z_impl_k_sem_give is called on sync sema
    api.on_basic_block(Some(symbolizer::resolve("hci_cmd_done.isra.0")? + 0x62), |_| on_bt_hci_cmd_done_check_sema_validity(send_sync_sema_states));

    // Bug: new-Bug-hci-send_sync-dangling-conn-state-ref
    let cmd_data = [ CmdData { state: 0, state_target: 0 }, CmdData { state: 0, state_target: 0 } ];
    api.on_prepare_run(|| { cmd_data[0].state = 0; cmd_data[1].state = 0; });
    // PORTING: Offset: Return from net_buf_id call just before bt_hci_cmd_send_sync
    // PORTING: Function name may have changed in newer versions. See bt_hci_cmd_state_set_init calls before bt_hci_cmd_send_sync (bt_le_create_conn_legacy, ...)
    api.on_basic_block(Some(symbolizer::resolve("set_le_adv_enable_legacy.constprop.0")? + 0x30), |_| on_set_le_adv_enable_legacy_send_sync(cmd_data));
    // PORTING: Offset: Return from net_buf_id call just before atomic_set_bit_to
    api.on_basic_block(Some(symbolizer::resolve("hci_cmd_done.isra.0")? + 0x32), |_| on_hci_cmd_done_state_update(cmd_data));

    // Bug: fixed-Bug-k_poll-race-condition
    // PORTING: z_impl_k_queue_get+a4 is just before `z_queue_node_peekÂ´
    // PORTING: arch_swap+20 is the basic block after `isb`
    // NOTE: Ignore other known bugs also resulting in a nullptr.
    //       The hook for `new-Bug-hci_prio_event_alloc_err_handling` triggers too late, use generic arch_swap not raising PendSV hook instead.
    let arch_swap = ArchSwap { bug: false, pendsv: false };
    api.on_prepare_run(|| { arch_swap.bug = false; arch_swap.pendsv = false; });
    api.on_basic_block(Some(symbolizer::resolve("arch_swap")?), |_| on_arch_swap_enter(arch_swap));
    api.on_basic_block(Some(symbolizer::resolve("z_arm_pendsv")?), |_| on_z_arm_pendsv(arch_swap));
    api.on_basic_block(Some(symbolizer::resolve("arch_swap")? + 0x20), |_| on_arch_swap_after_pendsv(arch_swap));
    api.on_basic_block(Some(symbolizer::resolve("z_impl_k_queue_get")? + 0xa4), |_| on_k_queue_get_poll(arch_swap, sent_cmd_state));

    // Bug: fixed-Bug-bt_att-resp-timeout-null-ptr
    // PORTING: Offset: In bt_att_sent after first NULL check
    api.on_basic_block(Some(symbolizer::resolve("bt_att_sent")? + 0x18), |_| on_bt_att_sent());
    // PORTING: Different BBs leading to calls of send_err_rsp or handlers
    api.on_basic_block(Some(symbolizer::resolve("bt_att_recv")? + 0x72), |_| on_bt_att_recv()); // send_err_rsp (1)
    api.on_basic_block(Some(symbolizer::resolve("bt_att_recv")? + 0x74), |_| on_bt_att_recv()); // send_err_rsp (2)
    api.on_basic_block(Some(symbolizer::resolve("bt_att_recv")? + 0xaa), |_| on_bt_att_recv()); // handler->func
    // PORTING: If CONFIG_BT_SMP is set, check for bt_att_encrypt_change call site (CONFIG_BT_SMP)
    // https://github.com/zephyrproject-rtos/zephyr/commit/577cd82#diff-3adc165d775d407a3eb6b90da365671eee38ca4e38d9b6f6661abf2975a5161eR2703
    // api.on_basic_block(Some(symbolizer::resolve("bt_att_encrypt_change")? + 0xTODO, on_bt_att_encrypt_change);
    // PORTING: bt_att_status after initial checks before att is used
    api.on_basic_block(Some(symbolizer::resolve("bt_att_status")? + 0x18), |_| on_bt_att_status());

    // Bug: fixed-Bug-bt-periph-update_conn_param-work-double-submit
    // PORTING: Offset: bb before calling k_delayed_work_submit_to_queue from conn_auto_initiate
    api.on_basic_block(Some(symbolizer::resolve("conn_auto_initiate")? + 0x106), |_| on_conn_auto_initiate_call_work_submit());
    // PORTING: Offset: bb before calling k_delayed_work_init from bt_conn_add_le
    api.on_basic_block(Some(symbolizer::resolve("bt_conn_add_le")? + 0x28), |_| on_bt_conn_add_le_work_init());

    // Bug: fixed-Bug-double-bt_att_chan_req_send-null-ptr
    // https://github.com/zephyrproject-rtos/zephyr/commit/bc7ce86ac5c234a92cfc6302452a9aa962ff4952
    api.on_basic_block(Some(symbolizer::resolve("bt_att_chan_req_send")? + 0x28), |_| on_bt_att_chan_req_send());

    // Bug: GENERIC-cmd_data-oob-index
    api.on_basic_block(Some(symbolizer::resolve("hci_cmd_done.isra.0")? + 0x1e), |_| on_cmd_data_index());
    api.on_basic_block(Some(symbolizer::resolve("bt_hci_cmd_create")? + 0x32), |_| on_cmd_data_index());
    api.on_basic_block(Some(symbolizer::resolve("bt_hci_cmd_send_sync")? + 0x24), |_| on_cmd_data_index());
    api.on_basic_block(Some(symbolizer::resolve("set_le_adv_enable_legacy.constprop.0")? + 0x30), |_| on_cmd_data_index());
}

fn on_bt_init(mtu_setup) {
    mtu_setup.hit = true;
}

fn on_semaphore_init(semaphores) {
    let sem = register::read("R0")?;
    semaphores.push(sem);

    // detect invalid semaphore init
    let initial_count = register::read("R1")?;
    let limit = register::read("R2")?;
    if limit == 0 || initial_count > limit {
        log::info!("invalid z_impl_k_sem_init call: sem = {:08x}, initial_count = {}, limit = {}", sem, initial_count, limit);
        input::add_bug(format!("GENERIC-invalid-sem-init-{:08x}", sem));
    }
}

fn on_CVE_2021_3329(semaphores, mtu_setup) {
    // semaphore init done?
    const sem = 0x20002f7c;
    let init = false;
    for addr in semaphores {
        if addr == sem {
            init = true;
            break;
        }
    }

    // CVE-2021-3329
    if mtu_setup.hit && !init {
        input::add_bug("CVE-2021-3329");
    }
}

fn on_z_impl_k_sem_take(semaphores) {
    let sem = register::read("R0")?;

    // semaphore init done?
    let init = false;
    for addr in semaphores {
        if addr == sem {
            init = true;
            break;
        }
    }

    // use sempahore before init?
    if !init {
        input::add_bug(format!("GENERIC-sem-not-init-{:08x}", sem));
    }
}

fn on_isr_entry(isr_state) {
    isr_state.depth += 1;
}

fn on_isr_exit(isr_state) {
    isr_state.depth -= 1;
}

fn on_net_buf_alloc_len_ret_check_nullptr_in_isr(isr_state) {
    // Check whether NULL is returned from blocking netbuf allocation when within an ISR
    if isr_state.depth > 0 {
        // PORTING: ensure r4 holds the return value
        let buf = register::read("R4")?;
        // PORTING: ensure r6 holds timeout
        let timeout = register::read("R6")?;

        // The bug triggers when NULL is returned from blocking net_buf_alloc while in an ISR
        const K_FOREVER = 0xffffffff;
        if timeout == K_FOREVER && buf == 0 {
            input::add_bug("new-Bug-hci_prio_event_alloc_err_handling");
        }
    }
}

// Parse fifo list at `fifo_addr` and check whether buffer `buf` is part of it
fn fifo_contains(fifo_addr, buf) {
    let next = fifo_addr;
    let nodes = [];

    while next != 0 {
        // detect loops
        for node in nodes {
            if node == next {
                return false;
            }
        }
        nodes.push(next);

        // buf found in fifo
        if next == buf {
            return true;
        }

        // resolve next list node
        // PYTHON: address may be unmapped and reading it will return an error, replace error with 0
        next = memory::read_u32(next).unwrap_or(0);
    }

    // end of list
    return false;
}

fn on_bt_buf_get_cmd_complete_sent_cmd_reuse(sent_cmd_state) {
    // Check whether sent_cmd is re-used while it is still in the output queue (tx.fifo)

    let tx_fifo = symbolizer::resolve("tx")? + 0x8; // tx.fifo (addr: 0x20003038)

    // PORTING: register assignment (r4 == sent_cmd)
    let sent_cmd_netbuf = register::read("R4")?;

    if fifo_contains(tx_fifo, sent_cmd_netbuf) {
        sent_cmd_state.is_buf_handed_out_when_in_tx_fifo = true;
    }
}

fn on_net_buf_put_check_rx_tx_fifo_state(sent_cmd_state) {
    // After the sent_cmd has been given out, is a buffer also added to rx.fifo while it is in tx.fifo?

    if sent_cmd_state.is_buf_handed_out_when_in_tx_fifo {
        let rx_fifo = symbolizer::resolve("rx")? + 4; // rx.fifo (addr: 0x20003014)
        let tx_fifo = symbolizer::resolve("tx")? + 8; // tx.fifo (addr: 0x20003038)
        let target_queue = register::read("R0")?;

        if target_queue == rx_fifo {
            let buf_to_add = register::read("R1")?;

            if fifo_contains(tx_fifo, buf_to_add) {
                input::add_bug("new-Bug-sent_cmd_shared_ref_race");
                sent_cmd_state.bug = true;
            }
        }
    }
}

fn on_bt_hci_cmd_send_sync_set_valid(send_sync_sema_states) {
    // After sync_sem is set up in bt_hci_cmd_send_sync and while z_impl_k_sem_take is called on it, sema may be used

    let net_buf_id = register::read("R0")?;
    let sema = register::read("SP")?;

    if net_buf_id == 0 || net_buf_id == 1 {
        send_sync_sema_states[net_buf_id].valid = true;
        send_sync_sema_states[net_buf_id].head = memory::read_u32(sema)?;
        send_sync_sema_states[net_buf_id].tail = memory::read_u32(sema+4)?;
    }
}

fn on_bt_hci_cmd_send_sync_set_invalid(send_sync_sema_states) {
    // After z_impl_k_sem_take has returned within bt_hci_cmd_send_sync, sema is no longer valid

    let net_buf_id = register::read("R0")?;

    if net_buf_id == 0 || net_buf_id == 1 {
        send_sync_sema_states[net_buf_id].valid = false;
    }
}

fn on_bt_hci_cmd_done_check_sema_validity(send_sync_sema_states) {
    // Check whether sync sema on command buffer is valid in case it is about to be used
    // PORTING: symbol cmd_data_0 + 8
    const GLOBAL_cmd_data_0_sync = 0x20000294 + 8;
    const CMD_DATA_SIZE = 0xc;
    let net_buf_id = register::read("R0")?;

    if net_buf_id == 0 || net_buf_id == 1 {
        if !send_sync_sema_states[net_buf_id].valid {
            let sema_ptr_addr = GLOBAL_cmd_data_0_sync + net_buf_id * CMD_DATA_SIZE;
            let sema_addr = memory::read_u32(sema_ptr_addr)?;

            // This in itself should not happen, but does not lead to an actual crash most of the time
            // This is why we check here whether the sema waitq addresses remained unchanged
            let head = memory::read_u32(sema_addr)?;
            let tail = memory::read_u32(sema_addr+4)?;
            if send_sync_sema_states[net_buf_id].head != head ||
                send_sync_sema_states[net_buf_id].tail != tail {
                    input::add_bug("new-Bug-hci-send_sync-dangling-sema-ref");
            }
        }
    }
}

fn on_arch_swap_enter(arch_swap) {
    arch_swap.pendsv = false;
}

fn on_z_arm_pendsv(arch_swap) {
    arch_swap.pendsv = true;
}

fn on_arch_swap_after_pendsv(arch_swap) {
    if !arch_swap.pendsv {
        arch_swap.bug = true;
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/99c2d2d0
// https://github.com/zephyrproject-rtos/zephyr/commit/b173e4353fe55c42ee7f77277e13106021ba5678
fn on_k_queue_get_poll(arch_swap, sent_cmd_state) {
    let other_bug = arch_swap.bug || sent_cmd_state.bug;
    let node = register::read("R0")?;

    // k_poll is racy and peeking is not atomic
    // queue head may be a nullptr by the time of use and the code **should** retry but does not => bug
    // NOTE: ignore known Bug(s) where arch_swap fails to raise an PendSV interrupt
    if node == 0 && !other_bug {
        input::add_bug("fixed-Bug-k_poll-race-condition");
    }
}

fn on_le_init_check_1(le_init) {
    // PORTING: Need to ensure that the rsp (response) variable is located at sp+0x4 here
    let rsp_ptr_ptr = register::read("SP")? + 4;
    let buf = memory::read_u32(rsp_ptr_ptr)?;

    // PORTING: Make sure that struct formats remain the same
    let data = memory::read_u32(buf + 8)?;

    // Offsets into struct bt_hci_rp_le_read_buffer_size (https://github.com/zephyrproject-rtos/zephyr/blob/e1dddf7befa7309bd2afc567b2e00d2e7362f7c4/include/bluetooth/hci.h#L600-L604)
    // rp->le_max_len
    let le_max_len = memory::read_u16(data + 1)?;
    // rp->le_max_num
    let le_max_num = memory::read_u8(data + 3)?;

    // Bug: if le_max_len is set, le_max_num is also expected to be non-zero (but check is missing)
    // for le_max_num == 0, the semaphore initialization is invalid
    if le_max_len != 0 && le_max_num == 0 {
        le_init.invalid_init = true;
    }
}

fn on_le_init_check_2(le_init) {
    // PORTING: Need to ensure that the rsp (response) variable is located at sp+0x4 here
    let rsp_ptr_ptr = register::read("SP")? + 4;
    let buf = memory::read_u32(rsp_ptr_ptr)?;

    // PORTING: Make sure that struct formats remain the same
    let data = memory::read_u32(buf + 8)?;

    // Offsets into struct bt_hci_rp_read_buffer_size (https://github.com/zephyrproject-rtos/zephyr/blob/e1dddf7befa7309bd2afc567b2e00d2e7362f7c4/include/bluetooth/hci.h#L555-L561)
    // rp->acl_max_len
    let acl_max_num = memory::read_u16(data + 4)?;

    if acl_max_num == 0 {
        le_init.invalid_init = true;
    }
}

fn on_le_init_sem_take(le_init) {
    // PORTING: &_data_ram_start.le.pkts == 0x20002F7C
    const LE_INIT_SEM = 0x20002F7C;

    // detect bug on actual usage of semaphore
    let sem = register::read("R0")?;
    if sem == LE_INIT_SEM && le_init.invalid_init {
        input::add_bug("new-Bug-invalid-init-le_read_buffer_size");
    }
}

fn on_timeout_callback() {
    let t = register::read("R0")?;
    let callback = memory::read_u32(t + 0xc)?;

    if callback == 0 {
        input::add_bug("GENERIC-invalid_timeout_callback");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/577cd82#diff-3adc165d775d407a3eb6b90da365671eee38ca4e38d9b6f6661abf2975a5161eR287
fn on_bt_att_sent() {
    // PORTING: r6 == att
    let att = register::read("R6")?;

    if att == 0 {
        input::add_bug("fixed-Bug-bt_att-resp-timeout-null-ptr");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/577cd82#diff-3adc165d775d407a3eb6b90da365671eee38ca4e38d9b6f6661abf2975a5161eR2441
fn on_bt_att_recv() {
    // PORTING: r6 == att_chan
    let att_chan = register::read("r6")?;
    let att = memory::read_u32(att_chan)?; // att_chan->att

    if att == 0 {
        input::add_bug("fixed-Bug-bt_att-resp-timeout-null-ptr");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/577cd82#diff-3adc165d775d407a3eb6b90da365671eee38ca4e38d9b6f6661abf2975a5161eR2752
fn on_bt_att_status() {
    // PORTING: r0 == ch
    let ch = register::read("r0")?;
    let att_chan = ch - 4;                 // ATT_CHAN(ch)
    let att = memory::read_u32(att_chan)?; // att_chan->att

    if att == 0 {
        input::add_bug("fixed-Bug-bt_att-resp-timeout-null-ptr");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/77b11d6
// The fix is implicit in the fact that submitting work is now guarded by conn state machine in bt_conn_set_state
fn on_conn_auto_initiate_call_work_submit() {
    // Check in conn_auto_initiate before submitting work that it is not already linked/added
    // This is the first known order in which the work timeout on connections may be used while already inserted

    // PORTING: struct offsets and r4==conn
    const STRU_OFF_conn_to_update_work = 0x50;
    const STRU_OFF_work_to_timeout = 0xc;
    let conn = register::read("r4")?;
    let update_work = conn + STRU_OFF_conn_to_update_work;
    let timeout = update_work + STRU_OFF_work_to_timeout;

    let timeout_list = symbolizer::resolve("timeout_list")?;
    if fifo_contains(timeout_list, timeout) {
        input::add_bug("fixed-Bug-bt-periph-update_conn_param-work-double-submit");
    }
}

fn on_bt_conn_add_le_work_init() {
    // Check in bt_conn_add_le before initializing work that it is not already linked/added.
    // This is the second known order in which the work timeout on connections may be used while already inserted

    // PORTING: struct offsets and r4==conn
    const STRU_OFF_conn_to_update_work = 0x50;
    const STRU_OFF_work_to_timeout = 0xc;
    let conn = register::read("r4")?;
    let update_work = conn + STRU_OFF_conn_to_update_work;
    let timeout = update_work + STRU_OFF_work_to_timeout;

    let timeout_list = symbolizer::resolve("timeout_list")?;
    if fifo_contains(timeout_list, timeout) {
        input::add_bug("fixed-Bug-bt-periph-update_conn_param-work-double-submit");
    }
}

fn on_k_delayed_work_init() {
    let work = register::read("r0")?;
    const STRU_OFF_work_to_timeout = 0xc;
    let timeout = work + STRU_OFF_work_to_timeout;

    let timeout_list = symbolizer::resolve("timeout_list")?;
    if fifo_contains(timeout_list, timeout) {
        input::add_bug("GENERIC-delayed_work_init-double-add");
    }

    // __ASSERT(!sys_dnode_is_linked(&to->node), ""); in z_add_timeout
    let next = memory::read_u32(timeout)?;
    if next != 0 {
        input::add_bug("GENERIC-delayed_work_init-sys_dnode_is_linked");
    }
}

fn on_z_add_timeout() {
    let to = register::read("r0")?;

    let timeout_list = symbolizer::resolve("timeout_list")?;
    if fifo_contains(timeout_list, to) {
        input::add_bug("GENERIC-add_timeout-double-add");
    }

    // __ASSERT(!sys_dnode_is_linked(&to->node), ""); in z_add_timeout
    let next = memory::read_u32(to)?;
    if next != 0 {
        input::add_bug("GENERIC-add_timeout-sys_dnode_is_linked");
    }
}

fn on_tx_free() {
    let tx = register::read("R0")?;

    if tx & 0xff == 0x02 {
        // NOTE: user_data buffer is reused in `send_frag` for `bt_send`
        // buf->user_data[0] = '\x02';
        // but `buf->user_data` is also a `tx` pointer
        // this error probably occurs due to a race condition / unexpected IRQ
        input::add_bug("GENERIC-invalid-tx_free");
    }    
}

fn on_set_le_adv_enable_legacy_send_sync(cmd_data) {
    // Save our local variable pointer when passing it to bt_hci_cmd_send_sync
    let index = register::read("R0")?;
    let state = register::read("SP")? + 4;
    let target = memory::read_u32(state)?;

    if index >= 2 {
        // OOB index for cmd_data, this is the result of another bug
        // we detect this condition with the GENERIC-cmd_data-oob-index hook
        return;
    }

    cmd_data[index].state = state;
    cmd_data[index].state_target = target;
}

fn on_hci_cmd_done_state_update(cmd_data) {
    // When state pointer is used in hci_cmd_done, check that its state->target has not been modified

    let index = register::read("R0")?;
    if index >= 2 {
        // OOB index for cmd_data, this is the result of another bug
        // we detect this condition with the GENERIC-cmd_data-oob-index hook
        return;
    }

    // PORTING: symbol cmd_data_0 + 4
    const GLOBAL_cmd_data_0_state = 0x20000294 + 4;
    const CMD_DATA_SIZE = 0xc;
    let cmd_data_ptr = GLOBAL_cmd_data_0_state + (CMD_DATA_SIZE * index);
    let state = memory::read_u32(cmd_data_ptr)?;

    if state != 0 {
        let target = memory::read_u32(state)?;

        // verify the state pointer to a value in the stack in set_le_adv_enable_legacy is still valid
        if target != cmd_data[index].state_target {
            input::add_bug("new-Bug-hci-send_sync-dangling-conn-state-ref");
        }
    }
}

fn on_bt_att_chan_req_send() {
    // Porting: req==r4, bt_att_req->buf offset
    let req = register::read("R4")?;
    let buf = memory::read_u32(req + 0x10)?;

    if buf == 0 {
        input::add_bug("fixed-Bug-double-bt_att_chan_req_send-null-ptr");
    }
}

fn on_cmd_data_index() {
    let index = register::read("R0")?;
    if index >= 2 {
        input::add_bug("GENERIC-cmd_data-oob-index");
    }
}

//size_t net_buf_simple_headroom(struct net_buf_simple *buf)
//{
//	return buf->data - buf->__buf;
//}
fn net_buf_simple_headroom(buf) {
    if buf == 0 {
        return 0;
    }

    let buf_data = memory::read_u32(buf)?;
    let buf___buf = memory::read_u32(buf+8)?;

    return buf_data - buf___buf;
}

fn on_net_buf_simple_push() {
    // __ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);
    let buf = register::read("R0")?;
    let len = register::read("R1")?;

    if net_buf_simple_headroom(buf) < len {
        let lr = register::read("lr")?;
        input::add_bug(format!("GENERIC-net_buf_simple_push-underflow-{:08x}", lr));
    }
}
