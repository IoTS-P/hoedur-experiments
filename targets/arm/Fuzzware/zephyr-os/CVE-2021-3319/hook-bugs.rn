struct Addr { ptr }

pub fn main(api) {
    // CVE check
    let mhr_src_addr = Addr { ptr: false };
    api.on_prepare_run(|| { mhr_src_addr.ptr = false; });
    // Hook different places in ieee802154_validate_frame (see comments below)
    api.on_basic_block(Some(0x0040d318), |pc| on_CVE_2021_3319(pc, mhr_src_addr));
    api.on_basic_block(Some(0x0040d390), |pc| on_CVE_2021_3319(pc, mhr_src_addr));
    api.on_basic_block(Some(0x0040d420), |pc| on_CVE_2021_3319(pc, mhr_src_addr));
    api.on_basic_block(Some(0x0040d41c), |pc| on_CVE_2021_3319(pc, mhr_src_addr));
}

fn on_CVE_2021_3319(pc, mhr_src_addr) {
    // Catch NULL return from validate_addr outside IEEE802154_ADDR_MODE_NONE
    // https://github.com/zephyrproject-rtos/zephyr/blob/0aaae4a039cab54df84c1f0371d44d6045ff58d8/subsys/net/l2/ieee802154/ieee802154_frame.c#L120

    // validate_addr is inlined in ieee802154_validate_frame for source and destination addresses
    // This is why we catch both cases (src and dest NULL assignment)
    // Source Address is combined as 0x0040d420 is reachable via multiple paths
    if pc == 0x0040d318 {
        // Reset tracking of whether we have a pointer when entering ieee802154_validate_frame
        mhr_src_addr.ptr = false;
    } else if pc == 0x0040d390 {
        // We are in the "is a pointer" path
        mhr_src_addr.ptr = true;
    } else if pc == 0x0040d420 {
        // Source address pointer assignment path triggered
        if mhr_src_addr.ptr {
            input::add_bug("CVE-2021-3319");
        }
    } else if pc == 0x0040d41c {
        // Destination address (NULL assignment only reached in buggy case)
        input::add_bug("CVE-2021-3319");
    }
}