const IEEE802154_FRAME_TYPE_ACK = 2;
const MEMMOVE_CALL_LOC_net_6lo_uncompress = 0x00407987;

pub fn main(api) {
    // CVE check
    api.on_basic_block(Some(symbolizer::resolve("memmove")?), |_| on_CVE_2020_10064());
    // Other CVEs triggerable in this target
    // Hook handling of incoming frames after initial sanity checks in ieee802154_recv
    api.on_basic_block(Some(symbolizer::resolve("ieee802154_recv")? + 0x42), |_| on_CVE_2021_3320());
    api.on_basic_block(Some(symbolizer::resolve("net_6lo_uncompress")?), |_| on_CVE_2021_3322());
    // Bug: fixed-Bug-fragment_header_len
    // Hook (inlined) handling of fragment_remove_headers in ieee802154_reassemble
    api.on_basic_block(Some(symbolizer::resolve("ieee802154_reassemble")? + 0x246), |_| on_fragment_remove_headers());
    // Bug: fixed-Bug-ipv6_get-iface-nullptr
    api.on_basic_block(Some(symbolizer::resolve("net_if_config_ipv6_get")?), |_| on_net_if_config_ipv6_get());
    // Bug: new-Bug-ipv6-nullptr
    api.on_basic_block(Some(symbolizer::resolve("net_if_ipv6_calc_reachable_time")?), |_| on_net_if_ipv6_calc_reachable_time());
}

fn on_CVE_2020_10064() {
    // Check for size underflow in memmove call from net_6lo_uncompress
    if register::read("R2")? > 0xf0000000 && register::read("LR")? == MEMMOVE_CALL_LOC_net_6lo_uncompress {
        input::add_bug("CVE-2020-10064");
    }
}

fn on_CVE_2021_3320() {
    if register::read("R3")? == IEEE802154_FRAME_TYPE_ACK {
        input::add_bug("COLLISION-CVE-2021-3320");
    }
}

fn on_CVE_2021_3322() {
    // Check for NULL ptr in pkt->frags
    let pkt = register::read("R0")?;
    let frags = memory::read_u32(pkt + 0x10)?;

    if frags == 0 {
        input::add_bug("COLLISION-CVE-2021-3322");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/d4b9620
// https://github.com/zephyrproject-rtos/zephyr/commit/897698b
fn on_net_if_config_ipv6_get() {
    let iface = register::read("R0")?;

    if iface == 0 {
        input::add_bug("fixed-Bug-ipv6_get-iface-nullptr");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/c6c2098
fn on_net_if_ipv6_calc_reachable_time() {
    // PORTING: net_if_ipv6_calc_reachable_time is called two times, but once with an address of a global variable.
    //          Thus, NULL can only be passed from handle_ra_input. Make sure no other calls were added.

    // net_pkt_iface(pkt)->config.ip.ipv6
    let ipv6 = register::read("R0")?;

    if ipv6 == 0 {
        input::add_bug("new-Bug-ipv6-nullptr");
    }
}

// https://github.com/zephyrproject-rtos/zephyr/commit/6068079
fn on_fragment_remove_headers() {
    // 00404826  a868       ldr     r0, [r5, #8]
    // 00404828  aa89       ldrh    r2, [r5, #0xc]
    // 0040482c  03f0f803   and     r3, r3, #0xf8
    // 00404830  c02b       cmp     r3, #0xc0

    let ptr = register::read("R5")?;
    let buf_len = memory::read_u16(ptr + 0xc)?;
    let datagram_type = memory::read_u8(ptr + 8)?;
    let hdr_len = 0;

    if datagram_type & 0xf8 == 0xc0 {
        hdr_len = 4;
    } else {
        hdr_len = 5;
    }

    if buf_len < hdr_len {
        input::add_bug("fixed-Bug-fragment_header_len");
    }
}
