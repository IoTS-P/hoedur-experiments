// PORTING: Hook after successfully passed bounds check of channel id after 2-byte memcpy
// Example assembly:
// .text:00205AA8                 SUB.W   R8, R3, #0x41
// .text:00205AAC                 UXTB.W  R2, R8            <- r8 == chan_ind
// .text:00205AB0                 CMP     R1, R2
// .text:00205AB2                 BLS.W   loc_205C48
// .text:00205AB6                 CMP     R3, #5            <- Hook location
//const HOOKED_ADDR = 0x00205ab6;
const HOOKED_ADDR = 0x00205b48;
// Alternative, portable hooking strategy: Hook memcpy and check return address for being close to the "input" symbol.
//                                         Then extract 2-byte channel id and pre-procompute the check/upper 8 bits for OOB index.

pub fn main(api) {
    // CVE check
    api.on_basic_block(Some(HOOKED_ADDR), |_| on_CVE());
}

fn on_CVE() {
    // PORTING: Check chan_ind variable register assignment
    //          this is the register that one byte is extracted from before the comparison
    let chan_ind = register::read("R6")?;

    if (chan_ind >> 8) & 0xff != 0 {
        input::add_bug("new-Bug-CVE-2022-41873");
    }
}
